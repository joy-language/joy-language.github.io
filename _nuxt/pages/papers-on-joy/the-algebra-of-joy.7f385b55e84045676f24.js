webpackJsonp([4],{"610A":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o=t("7QJG"),a=!1;var s=function(e){a||t("upwu")},i=t("VU/8")(null,o.a,!1,s,"data-v-fe51c94a",null);i.options.__file="pages/papers-on-joy/the-algebra-of-joy.vue",n.default=i.exports},"7QJG":function(e,n,t){"use strict";var o=function(){var e=this.$createElement;this._self._c;return this._m(0)};o._withStripped=!0;var a={render:o,staticRenderFns:[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("article",[t("h1",[e._v("The Algebra of Joy")]),t("i",[e._v(" by Manfred von Thun ")]),t("p",[t("em",[e._v("Abstract:")]),e._v(" Joy is a functional programming language which is not based\n    on the application of functions to arguments but on the composition of functions.\n    The language makes extensive use of combinators which perform the role of higher\n    order functions. The algebra of Joy programs can be used to express formal properties\n    of many first and second order functions without using variables ranging over values\n    or over functions. Some of these properties are idempotency, inverses, converses,\n    commutativity, symmetry, associativity, homomorphisms and distribution. The paper\n    also gives several analogues of concepts from category theory.\n  ")]),t("p",[t("em",[e._v("Keywords:")]),e._v(" functional programming, function composition, algebra of programs,\n    monoids, categories, functors, natural transformations, monads.\n  ")]),t("hr"),t("h2",[e._v("Introduction")]),e._v("\n  This paper describes a rich algebra of Joy programs which can be used for formal\n  manipulation of Joy programs. Concatenation of Joy programs denote the composition\n  of the functions which the concatenated parts denote. Hence if "),t("code",[e._v(" Q1 ")]),e._v("and "),t("code",[e._v(" Q2\n  ")]),e._v(" are programs which denote the same function and "),t("code",[e._v(" P\n  ")]),e._v(" and "),t("code",[e._v(" R ")]),e._v(" are other programs, then the two concatenations "),t("code",[e._v(" P Q1 R ")]),e._v("and "),t("code",[e._v(" P Q2 R ")]),e._v(" also denote the same function. In other words, programs\n  "),t("code",[e._v(" Q1 ")]),e._v(" and "),t("code",[e._v(" Q2 ")]),e._v(" can replace each other in concatenations.\n  This can serve as a rule of inference for "),t("em",[e._v("rewriting")]),e._v(".\n  "),t("p",[e._v("\n    As premises one needs axioms such as in the first three lines below, and definitions\n    such as in the fourth line:\n  ")]),t("pre",[e._v("(+)                2  3  +   ==   5\n  (dup)              5  dup   ==   5  5\n  (*)                5  5  *   ==   25\n  (def square)       square  ==  dup *\n  ")]),e._v("\n  A derivation using the above axioms and the definition looks like this:\n  "),t("pre",[e._v("                   2  3  +  square\n             ==      5  square                               (+)\n             ==      5  dup  *                               (def square)\n             ==      5  5  *                                 (dup)\n             ==      25                                      (*)\n  ")]),e._v("\n  The comments in the right margin explain how a line was obtained from the\n  previous line. The derivation shows that the expressions in the first line and the\n  last line denote the same function, or that the function in the first line is identical\n  with the function in the last line.\n  "),t("p",[e._v("\n    Consider the following equations in infix notation: The first says that multiplying\n    a number "),t("code",[e._v("x")]),e._v(" by 2 gives the same result as adding it to itself. The\n    second says that the "),t("kbd",[e._v("size")]),e._v(" of a\n    "),t("kbd",[e._v("reverse")]),e._v("d list is the same as the "),t("code",[e._v("size")]),e._v(" of the original list.\n  ")]),t("pre",[e._v("        2 * x  =  x + x                 size(reverse(x))  =  size(x)\n  ")]),e._v("\n  In Joy the same equations would be written, "),t("em",[e._v(" without\n  variables")]),e._v(", like this:\n  "),t("pre",[e._v("        2  *   ==   dup  +              reverse  size   ==   size\n  ")]),t("p",[e._v("\n    Other equivalences express algebraic properties of various operations. For example,\n    the predecessor "),t("kbd",[e._v("pred")]),e._v(" of the successor\n    "),t("kbd",[e._v("succ")]),e._v(" of a number is just the number itself. The conjunction "),t("kbd",[e._v("and")]),e._v("  of a truth value with itself gives just the truth value. The less than relation\n    "),t("code",[e._v("<")]),e._v(" is the converse of the greater than relation "),t("code",[e._v(">")]),e._v(".\n    Inserting a number with\n    "),t("kbd",[e._v("cons")]),e._v(" into a list of numbers and then taking the\n    "),t("kbd",[e._v("sum")]),e._v(" of that gives the same result as first taking the sum of the list\n    and then adding the other number.\n  ")]),t("p",[e._v("\n    In conventional notation these are expressed by\n  ")]),t("pre",[e._v("        pred(succ(x))  =  x             x and x  =  x\n          x <y  =  y > x                 sum(cons(x,y))  =  x + sum(y)\n  ")]),e._v("\n  In Joy these are expressed "),t("em",[e._v(" without variables")]),t("pre",[e._v("        succ  pred   ==   id            dup  and   ==   id\n          <  ==   swap >                 cons  sum   ==   sum  +\n  ")]),e._v("\n  Some properties of operations have to be expressed by combinators. One of\n  these is the "),t("kbd",[e._v("dip")]),e._v(" combinator which expects a program on top of the stack\n  and below that another value. It saves the value, executes the program on the remainder\n  of the stack and then restores the saved value.\n  "),t("p",[e._v("\n    In the first example below, the "),t("code",[e._v("dip")]),e._v(" combinator is used to express\n    the associativity of addition. Another combinator is the\n    "),t("kbd",[e._v("app2")]),e._v(" combinator which expects a program on top of the stack and below\n    that two values. It applies the program to the two values. In the second example\n    below it expresses one of the De Morgan laws. In the third example it expresses\n    that the "),t("code",[e._v("size")]),e._v(" of two lists "),t("kbd",[e._v("concat")]),e._v("enated is the sum of the\n    "),t("code",[e._v("size")]),e._v("s of the two concatenands. The last example uses both combinators\n    to express that multiplication distributes (from the right) over addition. (Note\n    that the program parameter for "),t("code",[e._v("app2")]),e._v(" is first constructed from the\n    multiplicand and "),t("code",[e._v("*")]),e._v(".)\n  ")]),t("pre",[e._v("        [+]  dip  +   ==   +  +\n          and  not   ==   [not]  app2  or\n          concat  size   ==   [size]  app2  +\n          [+]  dip  *   ==   [*]  cons  app2  +\n  ")]),t("p",[e._v("\n    The remainder of this paper is organised as follows: The next five sections give\n    detailed examples of algebraic laws which Joy operators satisfy. All of these laws\n    are well known when expressed in familiar notation, what is new here is that they\n    can be expressed in Joy notation without the use of implicitly or explicitly universally\n    quantified variables. Then follow three sections using concepts from category theory,\n    but no previous knowledge is assumed.\n  ")]),t("h2",[e._v("Idempotency, inverses and unit elements")]),e._v("\n  A unary function "),t("code",[e._v("f(x)")]),e._v(" is said to be "),t("em",[e._v("idempotent")]),e._v(' if applying\n  it once is "as good as" applying it twice. In conventional notation this means that\n  for all '),t("code",[e._v("x")]),t("pre",[e._v("        f(f(x))  =  f(x)\n  ")]),e._v("\n  For example, the function "),t("kbd",[e._v("abs")]),e._v(" which returns the absolute value\n  of a number is idempotent. Another one is the function defined on lists or strings\n  which returns a sorted version - sorting an already sorted sequence makes no difference.\n  "),t("pre",[e._v("        abs(abs(n))  =  abs(n)          sort(sort(s))  =  sort(s)\n  ")]),e._v("\n  Composition can be used to express that stack operations are\n  "),t("em",[e._v("idempotent")]),e._v(". The following express the idempotency of\n  "),t("kbd",[e._v("abs")]),e._v(" and "),t("kbd",[e._v("sort")]),e._v(":\n  "),t("pre",[e._v("        abs abs  ==  abs                sort sort  ==  sort\n  ")]),e._v("\n  Another idempotent Joy function, one which has no counterpart in conventional\n  notation, is the "),t("kbd",[e._v("newstack")]),e._v(" function, it throws away anything that is on\n  the stack. Doing it twice in succession gives the same result as doing it once:\n  "),t("pre",[e._v("        newstack  newstack   ==   newstack\n  ")]),t("p",[e._v("\n    The remainder of this section illustrates the use of the "),t("em",[e._v("identity\n    function")]),e._v(" in Joy algebra. This function is denoted by the symbol\n    "),t("kbd",[e._v("id")]),e._v(". It has the property that for all programs\n    "),t("code",[e._v("P")]),e._v(",\n  ")]),t("pre",[e._v("        id  P   ==   P   ==   P  id\n  ")]),t("p",[e._v("\n    Let "),t("code",[e._v("f(x)")]),e._v(" be a unary function. Another unary function\n    "),t("code",[e._v("g(x)")]),e._v(" is said to be its "),t("em",[e._v("inverse")]),e._v(" if for all\n    "),t("code",[e._v("x")])]),t("pre",[e._v("        g(f(x))  =  x\n  ")]),e._v("\n  For example, the predecessor function on integers is the inverse of the successor\n  function on integers: for all integers "),t("code",[e._v("x")]),t("pre",[e._v("        pred(succ(x))  =  x\n  ")]),e._v("\n  It may or may not be that if one function is the inverse of a second then\n  the second is the inverse of the first. This is true of the predecessor and successor\n  functions when defined on integers, but not when defined on natural numbers. The\n  identity function can be used to express that one function is the inverse of another\n  and that certain values are unit elements.\n  "),t("p",[e._v("\n    The atomic program "),t("kbd",[e._v("succ")]),e._v(" denotes a function which takes a stack as argument\n    and yields a stack as value. The argument stack has to have an integer (or a character)\n    on top. The value stack is like the argument stack except that the integer (or\n    character) has been incremented by 1. The semantics for "),t("kbd",[e._v("pred")]),e._v(" is analogous,\n    it decrements the integer (or character). The following express that the functions\n    denoted by the symbols "),t("code",[e._v("succ")]),e._v(" and\n    "),t("code",[e._v("pred")]),e._v(" are "),t("em",[e._v("inverse")]),e._v("s of each other:\n  ")]),t("pre",[e._v("        pred succ  ==  id               succ pred  ==  id\n  ")]),t("p",[e._v("\n    The "),t("kbd",[e._v("cons")]),e._v(" function expects a list on top of the argument stack. Below\n    that it expects another value. The value that is returned is another stack which\n    is like the argument stack except that the two top elements of the argument stack\n    have been replaced by a new list which has the value inserted into it at the front.\n    The\n    "),t("kbd",[e._v("uncons")]),e._v(" function undoes this. It expects a non-empty list and leaves\n    the first and the rest of the list. The two functions are inverses of each other:\n  ")]),t("pre",[e._v("        cons uncons  ==  id             uncons cons  ==  id\n  ")]),e._v("\n  It is worth pointing out this cannot be expressed in conventional notation\n  because there the "),t("code",[e._v("uncons")]),e._v(" operation makes no sense. Actually, both functions\n  are polymorphic in that instead of lists they can operate on strings or on sets The\n  two equations still hold applied to strings. Only the right equation holds for sets.\n  "),t("p",[e._v("\n    The symbols "),t("kbd",[e._v("pairlist")]),e._v(", "),t("kbd",[e._v("pairstring")]),e._v(" and\n    "),t("kbd",[e._v("pairset")]),e._v(" denote functions which expect two potential members of lists,\n    strings or sets on top of the stack. They return a new stack with the two members\n    replaced by a single list, string or set. The polymorphic "),t("kbd",[e._v("unpair")]),e._v(" function\n    is their inverse, but not vice versa. Since "),t("code",[e._v("unpair")]),e._v(" leaves two results,\n    the following have no counterpart in conventional notation.\n  ")]),t("pre",[e._v("        pairlist unpair  ==  id\n          pairstring unpair  ==  id\n          pairset unpair  ==  id\n  ")]),t("p",[e._v("\n    Some functions are inverses of themselves. Examples of\n    "),t("em",[e._v("self-inverse")]),e._v(" functions are the Boolean negation function and the list\n    reversal function: for all Boolean values "),t("code",[e._v("b")]),e._v(" and for all lists "),t("code",[e._v("l")])]),t("pre",[e._v("        not(not(b))  =  b               reverse(reverse(l))  =  l\n  ")]),e._v("\n  In Joy the two unary operators "),t("kbd",[e._v("not")]),e._v(" and "),t("kbd",[e._v("reverse")]),e._v(" are polymorphic.\n  The "),t("code",[e._v("not")]),e._v(" operator expects a truth value or a set on top of the stack\n  and returns a stack which has the complementary truth value or set on top of the\n  stack. The\n  "),t("code",[e._v("reverse")]),e._v(" operator expects a list or a string on top of the stack and\n  returns a stack which has the reversal the list or string on top of the stack. The\n  two functions are self-inverses, and this is expressed by\n  "),t("pre",[e._v("        not not  ==  id                 reverse reverse  ==  id\n  ")]),t("p",[e._v("\n    Let "),t("code",[e._v("f(x,y)")]),e._v(" be a binary function. A constant\n    "),t("code",[e._v("c")]),e._v(" is called a left or right "),t("em",[e._v("unit element")]),e._v(" if the first or\n    the second equation holds for all "),t("code",[e._v("x")])]),t("pre",[e._v("        f(c,x)  =  x                    f(x,c)  =  x\n  ")]),e._v("\n  Left and right unit elements often coincide, and then they are just called\n  unit elements. In particular, this is true for the unit elements of commutative functions.\n  For example, 0 is the unit element for addition, and 1 is the unit element for multiplication.\n  In conventional infix notation:\n  "),t("pre",[e._v("        n + 0  =  n  =  0 + n            n * 1  =  n  =  1 * n\n  ")]),t("p",[e._v("\n    The identity function can also be used to express that certain literals are "),t("em",[e._v("right unit")]),e._v("  elements for binary operations: 0 for addition, 1 for multiplication, the "),t("em",[e._v("empty string")]),t("code",[e._v('""')]),e._v(" or the "),t("em",[e._v("empty list")]),t("code",[e._v("[]")]),e._v(" for concatenation, the\n    truth value "),t("kbd",[e._v("false")]),e._v(" and the "),t("em",[e._v("empty\n    set")]),t("code",[e._v("{}")]),e._v(" for logical disjunction and set union, and the truth value\n    "),t("kbd",[e._v("true")]),e._v(" for logical conjunction.\n  ")]),t("pre",[e._v('        0 +  ==  id                     1 *  ==  id\n          "" concat  ==  id               [] concat  ==  id\n          false or  ==  id                {} or  ==  id\n          true and  ==  id\n  ')]),t("h2",[e._v("Idempotency, zero elements and arities")]),e._v("\n  This section illustrates the "),t("code",[e._v("dup")]),e._v(" and "),t("code",[e._v("pop")]),e._v(" operators in\n  Joy algebra. The Joy operator "),t("kbd",[e._v("dup")]),e._v(" expects one value on top of the stack\n  and pushes a duplicate on top. For example,\n  "),t("pre",[e._v("        42 dup  ==  42 42\n  ")]),e._v("\n  Both sides of the equation denote compositions of two functions. On the left\n  the first function pushes a number and the second makes a duplicate of the top element.\n  On the right the two functions are the same, each pushes a number. The equation says\n  that the function on the left is identical to the one on the right. Both functions\n  are defined for all stacks, and both return a stack which is like the argument stack\n  except that two copies of the number 42 have been pushed.\n  "),t("p",[e._v("\n    A binary function "),t("code",[e._v("f(x,y)")]),e._v(" is called "),t("em",[e._v("idempotent")]),e._v(" if for all\n    "),t("code",[e._v("x")])]),t("pre",[e._v("        f(x,x)  =  x\n  ")]),e._v("\n  Two examples are the Boolean conjunction and disjunction operations: for all\n  "),t("code",[e._v("b")]),t("pre",[e._v("        b and b  =  b                   b or b  =  b\n  ")]),e._v("\n  In Joy the "),t("code",[e._v("dup")]),e._v(" operator can express idempotency of the Boolean\n  operations "),t("kbd",[e._v("and")]),e._v(" and "),t("kbd",[e._v("or")]),e._v(" which are defined for truth values and\n  for sets. It can also express the idempotency of the numeric binary "),t("kbd",[e._v("min")]),e._v("and "),t("kbd",[e._v("max")]),e._v(" operators:\n  "),t("pre",[e._v("        dup and  ==  id                 dup or  ==  id\n          dup min  ==  id                 dip max  ==  id\n  ")]),t("p",[e._v("\n    The Joy operator "),t("kbd",[e._v("pop")]),e._v(" expects one value on top of the stack and removes\n    it. For example\n  ")]),t("pre",[e._v("        17 42 pop  ==  17\n  ")]),e._v("\n  On the left the composition of three functions first pushes two numbers and\n  then pops the second. On the right the function just pushes the first number. The\n  two functions are identical since for all argument stacks they have the same result\n  stack.\n  "),t("p",[e._v("\n    Let "),t("code",[e._v("f(x,y)")]),e._v(" be a binary function. A constant\n    "),t("code",[e._v("c")]),e._v(" is called a left or right "),t("em",[e._v("zero element")]),e._v(" of\n    "),t("code",[e._v("f(x,y)")]),e._v(" if the first or second equation holds for all\n    "),t("code",[e._v("x")]),e._v(":\n  ")]),t("pre",[e._v("        f(c,x)  =  c                    f(x,c)  =  c\n  ")]),e._v("\n  For example, the number zero is a left and right zero element for multiplication,\n  and in conventional infix notation the laws looks like this:\n  "),t("pre",[e._v("        0 * n  =  0                     n * 0  =  0\n  ")]),e._v("\n  The "),t("code",[e._v("pop")]),e._v(" operator can also be used to express that particular\n  values are zero elements for binary operations: 0 for multiplication, "),t("code",[e._v("false")]),e._v("and the empty set "),t("code",[e._v("{}")]),e._v(" for logical conjunction and set intersection, and\n  "),t("code",[e._v("true")]),e._v(" for logical disjunction.\n  "),t("pre",[e._v("        0 *  ==  pop 0\n          false and  ==  pop false         {} and  ==  pop {}\n          true or  ==  pop true\n  ")]),t("p",[e._v("\n    The two operators "),t("code",[e._v("dup")]),e._v(" and "),t("code",[e._v("pop")]),e._v(" are related by the identity\n  ")]),t("pre",[e._v("        dup pop  ==  id\n  ")]),e._v("\n  The "),t("code",[e._v("pop")]),e._v(" operator can also be used to express the\n  "),t("em",[e._v("arity")]),e._v(" of a function, the number of parameters which it expects. For example,\n  numbers are nullary, the successor function is unary, and addition is binary. There\n  is no way to express this in conventional notation. In Joy it is expressed by:\n  "),t("pre",[e._v("        42 pop  ==  id        succ pop  ==  pop        + pop  ==  pop pop\n  ")]),e._v("\n  Similar laws express that some operators return two results on the stack:\n  "),t("pre",[e._v("        uncons pop pop  ==  pop        dup pop pop  ==  pop\n  ")]),t("h2",[e._v("Converses, commutativity and symmetry")]),e._v("\n  This section illustrates the use of the "),t("code",[e._v("swap")]),e._v(" operator in Joy algebra.\n  The Joy operator "),t("kbd",[e._v("swap")]),e._v(" expects two values of any type on top of the stack;\n  its effect is to interchange them. The operator is its own inverse:\n  "),t("pre",[e._v("        swap swap  ==  id\n  ")]),t("p",[e._v("\n    Let "),t("code",[e._v("f(x,y)")]),e._v(" be a binary function. Another binary function\n    "),t("code",[e._v("g(x,y)")]),e._v(" is its "),t("em",[e._v("converse")]),e._v(" if for all "),t("code",[e._v("x")]),e._v(" and "),t("code",[e._v("y")])]),t("pre",[e._v("        f(x,y)  =  g(y,x)\n  ")]),e._v("\n  For example, the numeric comparison relation "),t("code",[e._v("<")]),e._v(" has as its\n  converse the relation "),t("code",[e._v(">")]),e._v(":\n  "),t("pre",[e._v("        (i <j)  =  (j > i)\n  ")]),e._v("\n  In Joy notation the "),t("code",[e._v("swap")]),e._v(" operator can express that comparison\n  predicates "),t("code",[e._v("<")]),e._v(" and "),t("code",[e._v("<=")]),e._v(" have as their converses the predicates\n  "),t("code",[e._v(">")]),e._v(" and "),t("code",[e._v(">=")]),e._v(" by the laws\n  "),t("pre",[e._v("        swap >   ==   <                swap >=    ==    <=\n  ")]),e._v("\n  The operator "),t("kbd",[e._v("swons")]),e._v(" is similar to "),t("code",[e._v("cons")]),e._v(", it expects\n  an aggregate and a new value on top of the stack. It leaves a new aggregate with\n  the value inserted. But whereas "),t("code",[e._v("cons")]),e._v(" expects the aggregate on top and\n  the value below, "),t("code",[e._v("swons")]),e._v(" expects them in the opposite order, the value\n  on top and the aggregate below. It follows that "),t("code",[e._v("swons")]),e._v(" is the converse\n  of\n  "),t("code",[e._v("cons")]),e._v(". In the same way, a binary string or list operation\n  "),t("kbd",[e._v("swoncat")]),e._v(" is defined to be the converse of\n  "),t("code",[e._v("concat")]),e._v(".\n  "),t("pre",[e._v("        swap cons  ==  swons            swap concat  ==  swoncat\n  ")]),t("p",[e._v("\n    One function is the converse of a second function if and only if the second is the\n    converse of the first. This says that converseness is a symmetric relation. In\n    Joy it is expressed by the following: for all programs "),t("code",[e._v("P")]),e._v(" and "),t("code",[e._v("Q")])]),t("pre",[e._v("        swap P  ==  Q    if and only if    swap Q  ==  P\n  ")]),e._v("\n  From this rule and the previous equalities it follows that\n  "),t("pre",[e._v("        swap < ==   >                  swap <=  ==  >=\n          swap swons  ==  cons            swap swoncat  ==  concat\n  ")]),t("p",[e._v("\n    A binary function "),t("code",[e._v("f(x,y)")]),e._v(" is "),t("em",[e._v("commutative")]),e._v(" if it is its own\n    converse - if for all "),t("code",[e._v("x")]),e._v(" and "),t("code",[e._v("y")])]),t("pre",[e._v("        f(x,y)  =  f(y,x)\n  ")]),e._v("\n  For example, addition of numbers is commutative, for all integers\n  "),t("code",[e._v("x")]),e._v(" and "),t("code",[e._v("y")]),t("pre",[e._v("        i + j  =  j + i\n  ")]),e._v("\n  In Joy the "),t("code",[e._v("swap")]),e._v(" operator can express that a function is commutative.\n  "),t("pre",[e._v("        swap +  ==  +                   swap *  ==  *\n          swap and  ==  and               swap or  ==  or\n          swap max  ==  max               swap min  ==  min\n  ")]),e._v("\n  Two sorted sequences can be combined with the "),t("kbd",[e._v("merge")]),e._v(" operator to\n  form one new sorted sequence. Unlike\n  "),t("kbd",[e._v("concat")]),e._v("enation, merging is commutative:\n  "),t("pre",[e._v("        swap merge  ==  merge\n  ")]),t("p",[e._v("\n    A function which yields a truth value is often called a\n    "),t("em",[e._v("predicate")]),e._v(". Commutative predicates are often called\n    "),t("em",[e._v("symmetric")]),e._v(". For example, the "),t("em",[e._v("identity relation")]),t("code",[e._v(" = ")]),e._v(", a binary predicate, is commutative or symmetric. Another is the\n    "),t("kbd",[e._v("equal")]),e._v(" predicate which tests lists for identity, including sublists and\n    their sublists. In conventional notation, for all integers or lists "),t("code",[e._v("x")]),e._v("  and "),t("code",[e._v("y")])]),t("pre",[e._v("        (i = j)  =  (j = i)        equal(x,y)  =  equal(y,x)\n  ")]),e._v("\n  Turning these concepts on themselves, the converse relation is symmetric:\n  for all functions "),t("code",[e._v("f")]),e._v(" and "),t("code",[e._v("g")]),t("pre",[e._v("        (g is the converse of f)  =  (f is the converse of g)\n  ")]),e._v("\n  The same is not true for the inverse relation. The "),t("code",[e._v("swap")]),e._v(" operator\n  can express that a binary predicate is "),t("em",[e._v("symmetric")]),e._v(". The following express\n  that "),t("code",[e._v(" = ")]),e._v(" and "),t("code",[e._v("equal")]),e._v(" are symmetric:\n  "),t("pre",[e._v("        swap =   ==   =                 swap equal  ==  equal\n  ")]),e._v("\n  With "),t("code",[e._v("swap")]),e._v(" one can express that elements are "),t("em",[e._v("left\n  unit")]),e._v(" elements for binary operations. In the case of operations such as addition\n  and the Boolean operations this already follows from their commutativity. On the\n  other hand, concatenation of strings or lists is not commutative, but the empty string\n  and the empty list are both right and left unit elements for concatenation. They\n  are also both right unit elements for "),t("kbd",[e._v("merge")]),e._v(".\n  "),t("pre",[e._v('        0 swap +  ==  id                1 swap *  ==  id\n          false swap or  == id            {} swap or  ==  id\n          true swap and  ==  id\n          "" swap concat  ==  id          [] swap concat  ==  id\n          "" swap merge  ==  id           [] swap merge  ==  id\n  ')]),t("p",[e._v("\n    Some operators leave two elements on top of the stack, and two such operator may\n    be related in the sense that they just leave the elements in a different order.\n    This can also be expressed by\n    "),t("code",[e._v("swap")]),e._v(":\n  ")]),t("pre",[e._v("        uncons swap  ==  unswons        unswons swap  ==  uncons\n  ")]),e._v("\n  There is even one operator which is related to itself in this way, and that\n  is "),t("code",[e._v("dup")]),e._v(":\n  "),t("pre",[e._v("        dup swap  ==  dup\n  ")]),t("p",[e._v("\n    Two operators related to "),t("code",[e._v("swap")]),e._v(" are "),t("kbd",[e._v("rollup")]),e._v(" and\n    "),t("kbd",[e._v("rolldown")]),e._v(". The "),t("code",[e._v("rollup")]),e._v(" operator moves the third and second\n    element on the stack into second and first position, and it moves the original\n    first element into third position. The\n    "),t("code",[e._v("rolldown")]),e._v(" operator moves the second and first element on the stack\n    into third and second position, and it moves the original third element into first\n    position. They can express laws such as\n  ")]),t("pre",[e._v("        rolldown  concat  concat   ==   concat swoncat\n          rollup  swoncat  concat   ==   swoncat  swoncat\n          rollup  merge  merge   ==   merge merge\n  ")]),e._v("\n  Their arities are expressed by\n  "),t("pre",[e._v("        swap  pop  pop   ==   pop  pop\n          rollup  pop  pop  pop   ==   pop  pop  pop\n          rolldown  pop  pop  pop   ==   pop  pop  pop\n  ")]),t("h2",[e._v("Associativity")]),t("p",[e._v("\n    This section illustrates the use of the "),t("code",[e._v("dip")]),e._v(" combinator in Joy algebra.\n  ")]),t("p",[e._v("\n    The three previous sections have shown how a few Joy operations can express a variety\n    of well-known laws. In the sections to follow more difficult Joy concepts will\n    be needed. These resemble higher order functions, but like everything else in Joy\n    they really are just functions from stacks to stacks. They differ from what are\n    called the operators in that they expect on top of the stack not just a passive\n    datum, but a quoted program which they execute. In accordance with an older terminology\n    they are here called "),t("em",[e._v("combinator")]),e._v("s.\n  ")]),t("p",[e._v("\n    One of these is the "),t("kbd",[e._v("dip")]),e._v(" combinator. It expects a quoted program on the\n    top of the stack, and below at least one value of any type. During execution it\n    removes the program and the value from the stack and saves them. Then it executes\n    the program on the remainder of the stack. Finally it restores the saved value\n    to the top of the stack. In most applications the program will be pushed just before\n    the combinator is to be applied. The combinator is useful for doing something to\n    the stack without disturbing the top value.\n  ")]),t("p",[e._v("\n    Here is an example:\n  ")]),t("pre",[e._v("        1 2 3 4 + * 5  ==  1 14 5\n          1 2 3 4 5 [+ *] dip  ==  1 14 5\n  ")]),e._v("\n  In the first line on the left the 3 and the 4 are immediately added, the result\n  is multiplied by the 2 to give 14, and then the 5 is pushed on top. In the second\n  line the 5 is pushed immediately after the 4, and consequently it is not possible\n  to add the 3 and 4 without popping the 5 first. So, the program "),t("code",[e._v("[+ *]")]),e._v("is pushed and then executed by "),t("code",[e._v("dip")]),e._v(". The results are the same as those\n  in the two (identical) right sides.\n  "),t("p",[e._v("\n    A binary function "),t("code",[e._v("f(x,y)")]),e._v(" is said to be\n    "),t("em",[e._v("associative")]),e._v(" if the result of applying it twice to three values is independent\n    of the order of application:\n  ")]),t("pre",[e._v("        f(x,f(y,z))  =  f(f(x,y),z)\n  ")]),e._v("\n  For example, addition of numbers is associative:\n  "),t("pre",[e._v("        i + (j + k)  =  (i + j) + k\n  ")]),e._v("\n  If "),t("code",[e._v("g(x,y)")]),e._v(" is the converse of an associative\n  "),t("code",[e._v("f(x,y)")]),e._v(", then "),t("code",[e._v("g(x,y)")]),e._v(" is also associative.\n  "),t("p",[e._v("\n    In Joy the "),t("code",[e._v("dip")]),e._v(" combinator can be used to express associativity:\n  ")]),t("pre",[e._v("        [+] dip +  ==  + +              [*] dip *  ==  * *\n          [and] dip and  ==  and and      [or] dip or  ==  or or\n          [max] dip max  ==  max max      [min] dip min  ==  min min\n          [concat] dip concat  ==  concat concat\n          [swoncat] dip swoncat  ==  swoncat swoncat\n          [merge] dip merge  ==  merge merge\n  ")]),t("p",[e._v("\n    The following law expresses that the "),t("code",[e._v("dip")]),e._v(" combinator leaves one value\n    unchanged:\n  ")]),t("pre",[e._v("        dip  pop   ==   [pop]  dip  i\n  ")]),t("h2",[e._v("Homomorphisms, De Morgan and distribution")]),e._v("\n  This section illustrates the use of the "),t("code",[e._v("app2")]),e._v(" combinator in Joy algebra.\n  "),t("p",[e._v("\n    The "),t("kbd",[e._v("app2")]),e._v(" combinator expects a quoted program on top of the stack, and\n    below that two data parameters. As with all combinators, the program will be executed,\n    in this case twice. In case the program computes a unary function, the effect is\n    to replace the two data parameters by two corresponding values of that function.\n    The two evaluations could be done in parallel. The more general case where the\n    program does not denote a unary function is described further down.\n  ")]),t("p",[e._v("\n    Let "),t("code",[e._v("f(x1,x2)")]),e._v(" be a binary function defined on a type\n    "),t("code",[e._v("X")]),e._v(", and let "),t("code",[e._v("g(y1,y2)")]),e._v(" be a binary function defined on a\n    type "),t("code",[e._v("Y")]),e._v(". Let "),t("code",[e._v("h(x)")]),e._v(" be a function from "),t("code",[e._v("X")]),e._v(" to\n    "),t("code",[e._v("Y")]),e._v(". Then "),t("code",[e._v("h(x)")]),e._v(" is a\n    "),t("em",[e._v("homomorphism")]),e._v(" from "),t("code",[e._v("X")]),e._v(" and its binary function to\n    "),t("code",[e._v("Y")]),e._v(" and its binary function when the following holds for all "),t("code",[e._v("x1")]),e._v("  and "),t("code",[e._v("x2")]),e._v(":\n  ")]),t("pre",[e._v("        h(f(x1,x2)  =  g(h(x1),h(x2))\n  ")]),e._v("\n  One example is the logarithm function which maps logarithms of products onto\n  sums of logarithms. Two other examples are the doubling function which maps integers\n  with addition into even integers with addition, and the squaring function which maps\n  naturals with multiplication into square naturals with multiplication and the\n  "),t("kbd",[e._v("size")]),e._v(" (or length) of string function which maps the size of concatenations\n  onto sums of sizes. The "),t("em",[e._v("De Morgan")]),e._v(" laws are another example.\n  "),t("pre",[e._v("        log(x * y)  =  log(x) + log(y)\n          double(x + y)  =  double(x) + double(y)\n          square(x * y)  =  square(x) * square(y)\n          size(concat(x,y))  =  size(x) + size(y)\n          not(p and q)  =  not p or not q\n          not(p or q)  =  not p and not q\n  ")]),t("p",[e._v("\n    In Joy the "),t("code",[e._v("app2")]),e._v(" combinator can be used to express\n    "),t("em",[e._v("homomorphism")]),e._v(" laws, and these all take the form:\n  ")]),t("pre",[e._v("        f  h   ==   [h]  app2  g\n  ")]),e._v("\n  Some such laws are\n  "),t("pre",[e._v("        +  double   ==   [double]  app2  +\n          *  square   ==   [square]  app2  *\n          max  succ   ==   [succ]  app2  max\n          concat  size   ==   [size]  app2  +\n          concat  sum   ==   [sum]  app2  +\n          concat  product   ==   [product]  app2  *\n          concat  charset   ==   [charset]  app2  or\n  ")]),e._v("\n  In the above, "),t("kbd",[e._v("charset")]),e._v(" transforms a string of characters into a\n  set of characters, and the "),t("code",[e._v("or")]),e._v(" operator computes set union in this case.\n  Another homomorphism is the "),t("kbd",[e._v("sort")]),e._v(" operator which maps unordered lists under\n  concatenation onto ordered lists under a binary "),t("kbd",[e._v("merge")]),e._v(" operator which preseves\n  ordering:\n  "),t("pre",[e._v("        concat  sort   ==   [sort]  app2  merge\n  ")]),t("p",[e._v("\n    The "),t("code",[e._v("app2")]),e._v(" combinator can also be used to express the familiar De Morgan\n    laws for Boolean algebra and a (perhaps surprising) isomorphic pair of laws for\n    strings or lists:\n  ")]),t("pre",[e._v("        and not  ==  [not] app2 or\n          or not  ==  [not] app2 and\n          concat reverse  ==  [reverse] app2 swoncat\n          swoncat reverse  ==  [reverse] app2 concat\n  ")]),t("p",[e._v("\n    Laws like the above generalise to "),t("em",[e._v("distribution")]),e._v(" laws. In these the unary\n    function is replaced by a new binary function, and for each element in the domain\n    a unary function can be defined from the new binary function by letting one parameter\n    be the given element. It is useful to distinguish "),t("em",[e._v("right distribution")]),e._v(" and\n    "),t("em",[e._v("left\n    distribution")]),e._v(".\n  ")]),t("p",[e._v("\n    A binary function "),t("code",[e._v("f(x,y)")]),e._v(" distributes from the right over another binary\n    function "),t("code",[e._v("g(x,y)")]),e._v(" if the following holds:\n  ")]),t("pre",[e._v("        f(g(x,y),z)  =  g(f(x,z),f(y,z))\n  ")]),e._v("\n  In arithmetic we have the familiar example of multiplication distributing\n  from the right over addition. In Boolean algebra the conjunction and disjunction\n  operators distribute from the right over\n  "),t("em",[e._v(" each other")]),e._v(". Here is the arithmetic law:\n  "),t("pre",[e._v("        (i + j) * k  =  (i * k) + (j * k)\n  ")]),t("p",[e._v("\n    The "),t("code",[e._v("app2")]),e._v(" combinator can also express "),t("em",[e._v("right\n    distribution")]),e._v(" laws. In each case there are three data parameters on the stack,\n    and the two ways of applying two functions are equivalent. The one way is to apply\n    the one function to the second and third parameters (using the "),t("code",[e._v("dip")]),e._v("  combinator) and then to apply the distributing function to the result and the first\n    parameters. The other way is to use the first parameter and the distributing function\n    to make a "),t("em",[e._v("constructed program")]),e._v(" that computes a unary function, use "),t("code",[e._v("app2")]),e._v("  to compute its values for the second and third data parameters and to combine the\n    two values with the other function.\n  ")]),t("pre",[e._v("        [+] dip *  ==  [*] cons app2 +\n          [and] dip or  ==  [or] cons app2 and\n          [or] dip and  ==  [and] cons app2 or\n  ")]),t("p",[e._v("\n    A binary function "),t("code",[e._v("f(x,y)")]),e._v(" distributes from the left over another binary\n    function "),t("code",[e._v("g(x,y)")]),e._v(" if the following holds:\n  ")]),t("pre",[e._v("        f(x,g(y,z))  =  g(f(x,z),f(y,z))\n  ")]),e._v("\n  In arithmetic multiplication also distributes from the left over addition:\n  "),t("pre",[e._v("        i * (j + k)  =  i * j + i * k\n  ")]),e._v("\n  The "),t("code",[e._v("app2")]),e._v(" combinator can also be applied to a quoted program which\n  does not compute a unary function, but accesses data elements further down in the\n  stack. In the examples below, these elements have to be explicitly deleted later\n  on, by "),t("code",[e._v("[pop]\n  dip")]),e._v(". It can be used to express "),t("em",[e._v("left distribution")]),e._v(" laws.\n  "),t("pre",[e._v("        + *  ==  [*] app2 + [pop] dip\n          or and  ==  [and] app2 or [pop] dip\n          and or  ==  [or] app2 and [pop] dip\n  ")]),t("p",[e._v("\n    Apart from "),t("code",[e._v("app2")]),e._v(" there are similar combinators\n    "),t("kbd",[e._v("app1")]),e._v(" and "),t("kbd",[e._v("app3")]),e._v(". Each expects a program\n    "),t("code",[e._v("[P]")]),e._v(" on top of the stack and below that 1, 2 or 3 further parameters\n    and produces 1, 2 or 3 values. Some pertinent laws are\n  ")]),t("pre",[e._v("        [succ]  app1  ==  succ            [not]  app1  ==  not\n          [pop]  dip  app1   ==   app2  pop\n          [swap]  dip  app2   ==   app2  swap\n          [dup]  dip  app2   ==   app1  dup\n  ")]),e._v("\n  The arities of these combinators are expressed by\n  "),t("pre",[e._v("        app1  pop   ==   pop  pop\n          app2  pop  pop   ==   pop  pop  pop\n          app3  pop  pop  pop   ==   pop  pop  pop  pop\n  ")]),t("p",[e._v("\n    There is a sense in which one might say that an integer has two parts: a sign and\n    an absolute value. When the two parts are multiplied, the result is the same as\n    the original. In the same way, a non-empty list has two parts, its first and its\n    rest. When the first is consed into the rest, the result is the same as the original\n    list. In conventional notation this might be expressed as\n  ")]),t("pre",[e._v("        sign(x) * abs(x)  =  x\n          cons(first(x),rest(x))  =  x\n  ")]),e._v("\n  The same may be expressed in Joy notation using the "),t("code",[e._v("dip")]),e._v(" combinator:\n  "),t("pre",[e._v("        dup [sign] dip abs *  ==  id\n          dup [first] dip rest cons  ==  id\n  ")]),t("p",[e._v("\n    The laws look somewhat cleaner when expressed in terms of another combinator. The\n    "),t("kbd",[e._v("cleave")]),e._v(" combinator expects two programs and below that another item.\n    It applies both programs to produce two results, for example\n  ")]),t("pre",[e._v("        5  [pred]  [dup *]  cleave   ==   4  25\n  ")]),e._v("\n  The earlier laws about parts and wholes can then be expressed like this:\n  "),t("pre",[e._v("        [sign]  [abs]  cleave  *   ==   id\n          [first]  [rest]  cleave  cons   ==  id\n  ")]),t("p",[e._v("\n    The combinator "),t("kbd",[e._v("split")]),e._v(" applied to a list and a test predicate produces\n    two lists, those members of the original list which pass the test and those with\n    fail. For any predicate, a list will have two parts which can be merged to reconstitute\n    the original list. In Joy notation:\n  ")]),t("pre",[e._v("        [sort] dip split merge   ==   pop  sort\n  ")]),e._v("\n  The law cannot be expressed in conventional notation because\n  "),t("code",[e._v("split")]),e._v(" produces two results.\n  "),t("h2",[e._v("The LIST functor and its natural transformations")]),e._v("\n  This section uses several concepts from category theory. The following brief sketch\n  is unavoidably superficial, for a proper exposition see "),t("a",{attrs:{href:"refs.html#{Rydeheard85}"}},[e._v("{Rydeheard85}")]),t("a",{attrs:{href:"refs.html#{Poigne92}"}},[e._v("{Poigne92}")]),e._v(". For excellent short introductions\n  for computer science see "),t("a",{attrs:{href:"refs.html#{Tennent91}"}},[e._v("{Tennent91}")]),e._v(" and\n  "),t("a",{attrs:{href:"refs.html#{Walters91}"}},[e._v("{Walters91}")]),e._v(". Another short introduction with\n  an extensive bibliography is\n  "),t("a",{attrs:{href:"refs.html#{Pierce91}"}},[e._v("{Pierce91}")]),e._v(".\n  "),t("p",[e._v("\n    A "),t("em",[e._v("category")]),e._v(" consists of a collection of "),t("em",[e._v("object")]),e._v("s and for any two\n    objects a collection of "),t("em",[e._v("morphism")]),e._v("s, each having the one object as their\n    "),t("em",[e._v("source")]),e._v(" and the other object as their\n    "),t("em",[e._v("target")]),e._v(". In many categories the objects are just sets, or they are sets\n    with structure - algebras. Then the morphisms are unary functions from sets to\n    sets, or they are homomorphisms from algebras to algebras. For any object the morphisms\n    must include an\n    "),t("em",[e._v("identity morphism")]),e._v(" with that object as source and target. Often there will\n    be other morphisms with that object as source and target. For any object and two\n    morphisms having a given object as target and source respectively, there must be\n    a composite morphism having as source the source of the one component and as target\n    the target of the other.\n  ")]),t("p",[e._v("\n    This composition of morphisms must be associative, with identity morphisms as left\n    and right unit elements. These requirements are satisfied for categories of sets\n    and functions and for categories of algebras and homomorphisms. But there are many\n    categories that are quite different. One kind of example are "),t("em",[e._v("monoid")]),e._v("s:\n    an associative binary operation over a set which includes a left and right unit\n    element. Here the category consists of just one object (which is of no interest),\n    but many morphisms, the elements of the monoid. There are many other kinds of categories\n    which are different again.\n  ")]),t("p",[e._v("\n    Categories deal with two sorts of things, objects and morphisms. So they are two-sorted\n    algebras. Between categories there are morphisms called "),t("em",[e._v("functor")]),e._v("s. These\n    take objects and morphims of one category into objects and morphisms of another\n    category. In computer science the most familiar functors are the "),t("em",[e._v("type constructor")]),e._v("s.\n    They take integers, characters, truth values and so on into\n    "),t("code",[e._v("LIST")]),e._v("s of integers, "),t("code",[e._v("LIST")]),e._v("s of characters,\n    "),t("code",[e._v("SET")]),e._v("s of integers and so on. The functors must "),t("em",[e._v("\n    also")]),e._v(" take integer functions such as squaring into corresponding functions on\n    "),t("code",[e._v("LIST")]),e._v("s or "),t("code",[e._v("SET")]),e._v("s of integers.\n  ")]),t("p",[e._v("\n    In computing circles the corresponding functions are usually written\n    "),t("code",[e._v("map(square,L)")]),e._v(", for a list "),t("code",[e._v("L")]),e._v(". In category theory the same\n    symbol is used for objects and morphisms, so the examples are written "),t("code",[e._v("LIST(integer)")]),e._v("  and\n    "),t("code",[e._v("LIST(square)")]),e._v(". In Joy there is no explicit type notation at all, and\n    "),t("kbd",[e._v("map")]),e._v(" is just one of many combinators. Programs to compute the list of\n    squares of a given list can be written in either of these two ways:\n  ")]),t("pre",[e._v("        [square]  map                   [dup *]  map\n  ")]),t("p",[e._v("\n    Between any two functors "),t("code",[e._v("F")]),e._v(" and "),t("code",[e._v("G")]),e._v(" there can be functions\n    called "),t("em",[e._v("natural transformation")]),e._v("s. These take as arguments the values of\n    "),t("code",[e._v("F")]),e._v(" and "),t("code",[e._v("G")]),e._v(" at their objects. A function "),t("code",[e._v("n")]),e._v(" is\n    natural if for all morhisms\n    "),t("code",[e._v("m")]),e._v(" in the domains of "),t("code",[e._v("F")]),e._v(" and "),t("code",[e._v("G")]),e._v(" the following\n    holds for all "),t("code",[e._v("x")]),e._v(":\n  ")]),t("pre",[e._v("        n(F(m)(x))  =  G(m)(n(x))\n  ")]),e._v("\n  Initially we shall only be concerned with the case where\n  "),t("code",[e._v("F")]),e._v(" and "),t("code",[e._v("G")]),e._v(" are the same functor\n  "),t("code",[e._v("LIST")]),e._v(". Then an example of a natural transformation from lists to lists\n  is the "),t("kbd",[e._v("reverse")]),e._v(" function: for all functions\n  "),t("code",[e._v("f")]),e._v(" and lists "),t("code",[e._v("L")]),t("pre",[e._v("        reverse(LIST(f)(L)  =  LIST(f)(reverse(L))\n  ")]),e._v("\n  or in conventional notation\n  "),t("pre",[e._v("        reverse(map(f,L))  =  map(f,reverse(L))\n  ")]),e._v("\n  In Joy algebra the naturality of "),t("code",[e._v("reverse")]),e._v(" is expressed by\n  "),t("pre",[e._v("        [reverse]  dip  map   ==   map  reverse\n  ")]),t("p",[e._v("\n    In computer science natural transformations are often called\n    "),t("em",[e._v("polymorphic")]),e._v(" functions, in the case of lists they are independent of the\n    type of the elements of the lists. Four other naturality laws, expressed in conventional\n    notation:\n  ")]),t("pre",[e._v("        map(f,rest(L))  =  rest(map(f,L))\n          f(first(L))  =  first(map(f,L))\n          map(f,concat(L1,L2))  =  concat(map(f,L1),map(f,L2))\n          map(f,cons(x,[]))  =  cons(f(x),[])\n          map(f,unitlist(x))  =  unitlist(f(x))\n  ")]),e._v("\n  The last two laws of course say the same thing. In Joy these would be expressed\n  by\n  "),t("pre",[e._v("        [rest]  dip  map   ==   map  rest\n          [first]  dip  i   ==   map  first\n          [concat]  dip  map   ==   [map]  cons  app2  concat\n          [[] cons] dip map   ==   i [] cons\n          [unitlist] dip map   ==   i  unitlist\n  ")]),e._v("\n  Note that in the third equation on the right the "),t("code",[e._v("app2")]),e._v(" combinator\n  has to use a "),t("em",[e._v("constructed program")]),e._v(". The last two laws again say the same thing.\n  "),t("p",[e._v("\n    Somewhat more difficult is the naturality of "),t("kbd",[e._v("cons")]),e._v(". In conventional notation\n    this is expressed by\n  ")]),t("pre",[e._v("        map(f,cons(x,L))  =  cons(f(x),map(f,L))\n  ")]),e._v("\n  and in Joy notation by\n  "),t("pre",[e._v("        [cons]  dip  map   ==   dup  [dip]  dip  map  cons\n  ")]),e._v("\n  This is so complex that a step-by-step verification is called for. Let "),t("code",[e._v("L")]),e._v("and "),t("code",[e._v("x")]),e._v(" be the list and the additional member. Let "),t("code",[e._v("[F]")]),e._v(" be\n  a program which computes the function\n  "),t("code",[e._v("f")]),e._v(". Let "),t("code",[e._v("x'")]),e._v(" be the result of applying\n  "),t("code",[e._v("f")]),e._v(" to "),t("code",[e._v("x")]),e._v(", and let "),t("code",[e._v("L'")]),e._v(" be the result of applying\n  "),t("code",[e._v("f")]),e._v(" to all members of "),t("code",[e._v("L")]),e._v(". The proof of the equivalence of\n  the LHS and the RHS consists in showing that both reduce to the same program. For\n  the LHS we have:\n  "),t("pre",[e._v("        x  L  [F]  [cons]  dip  map                             LHS\n      ==  x  L  cons  [F]  map                                    (dip)\n      ==  [x L]  [F]  map                                         (cons)\n      ==  [x' L']                                                 (map)\n  ")]),e._v("\n  For the RHS:\n  "),t("pre",[e._v("        x  L  [F]  dup  [dip]  dip  map  cons                   RHS\n      ==  x  L  [F]  [F]  [dip]  dip  map  cons                   (dup)\n      ==  x  L  [F]  dip  [F]  map  cons                          (dip)\n      ==  x'  L  [F]  map  cons                                   (dip)\n      ==  x'  L' cons                                             (map)\n      ==  [x' L']                                                 (cons)\n  ")]),e._v("\n  The two sides reduce to the same program, so they denote the same function.\n  "),t("p",[e._v("\n    A similar equation is the following:\n  ")]),t("pre",[e._v("        map   ==   [uncons]  dip  dup  [dip]  dip  map  cons\n  ")]),e._v("\n  But note that this is not suitable as a definition, since the RHS only applies\n  to non-empty lists. The following is a suitable recursive definition:\n  "),t("pre",[e._v("        map   ==   [ pop null ]\n                     [ pop ]\n                     [ [uncons]  dip  dup  [dip]  dip  map  cons ]\n                     ifte\n  ")]),t("p",[e._v("\n    The fact that "),t("code",[e._v("map")]),e._v(" does not change the number of elements in a list\n    is expressed in conventional notation by\n  ")]),t("pre",[e._v("        size(map(f,L))  =  size(L)\n  ")]),e._v("\n  and in Joy notation by\n  "),t("pre",[e._v("        map  size   ==   pop  size\n  ")]),t("p",[e._v("\n    An important combinator for any aggregate is "),t("kbd",[e._v("filter")]),e._v(", which expects an\n    aggregate and below that a quotation which implememnts a predicate. It returns\n    an aggregate of the same type as the parameter containing only those members for\n    which the predicate yielded\n    "),t("code",[e._v("true")]),e._v(". Given two aggregates, it does not matter whether they are first\n    combined and then filtered, or first filtered separately and then combined. For\n    sequences the law is this:\n  ")]),t("pre",[e._v("        [concat] dip filter  ==  [filter] cons app2 concat\n  ")]),e._v("\n  For sets the combining operator has to be "),t("code",[e._v("or")]),e._v(" instead of\n  "),t("code",[e._v("concat")]),e._v(".\n  "),t("p",[e._v("\n    Another law concerns passing an aggregate first through one filter and then passing\n    the result through another filter. Passing the aggregate through the conjunction\n    of these filters produces the same result. The "),t("kbd",[e._v("conjoin")]),e._v(" operator takes\n    two quoted predicates and returns one quoted predicate which is their conjunction.\n  ")]),t("pre",[e._v("        [filter] dip filter  ==  conjoin filter\n  ")]),t("p",[e._v("\n    The following laws concern the "),t("code",[e._v("sum")]),e._v("s and\n    "),t("code",[e._v("product")]),e._v("s of lists of integers:\n  ")]),t("pre",[e._v("        cons  sum   ==   sum  +         sum   ==   uncons  sum  +\n          cons product  ==  product *     product  ==  uncons product *\n  ")]),e._v("\n  (Only the equations on the left could be expressed in conventional notation.)\n  "),t("p",[e._v("\n    This holds:\n  ")]),t("pre",[e._v("        P  ==  uncons Q   iff   cons P  == Q\n  ")]),t("h2",[e._v("Other functors and their natural transformations")]),e._v("\n  As indicated in the previous section, apart from "),t("code",[e._v("LIST")]),e._v(" there are other\n  functors such as "),t("code",[e._v("SET")]),e._v(". So there is the type "),t("code",[e._v("SET(integer)")]),e._v(",\n  the function "),t("code",[e._v("SET(square)")]),e._v(" which maps a set of integers into the set of\n  their squares, and similarly for other integer functions. Much of what was said about\n  lists and their natural transformations has counterparts for sets and their natural\n  transformations. In Joy there are several implementations of "),t("em",[e._v("set type")]),e._v("s.\n  The simplest is in terms of bitstrings with potential elements "),t("code",[e._v("0")]),e._v(" ..\n  "),t("code",[e._v("31")]),e._v(", such sets are written in curly braces, as in "),t("code",[e._v("{1 3 5}")]),e._v(".\n  Values of this type can be manipulated by the combinator\n  "),t("code",[e._v("map")]),e._v(" and the operators "),t("code",[e._v("first")]),e._v(",\n  "),t("code",[e._v("rest")]),e._v(" and "),t("code",[e._v("cons")]),e._v(". Instead of the operator\n  "),t("code",[e._v("concat")]),e._v(" the set union operator "),t("kbd",[e._v("or")]),e._v(" applies. The naturality\n  of these operators is expressed by\n  "),t("pre",[e._v("        [rest]  dip  map   ==   map  rest\n          [first]  dip  map   ==   map  first\n          [or]  dip  map   ==   [map]  cons  app2  or\n          [{} cons]  dip  map   ==   i  {}  cons\n          [cons]  dip  map   ==   dup  [dip]  dip  map  cons\n  ")]),t("p",[e._v("\n    Now we have two functors, "),t("code",[e._v("LIST")]),e._v(" and "),t("code",[e._v("SET")]),e._v(". Lists have order\n    and may have repetitions, sets have neither. A useful function from lists to sets\n    is the function "),t("kbd",[e._v("elements")]),e._v(" which removes order and repetitions. For example,\n    in Joy notation\n  ")]),t("pre",[e._v("        [ 3 1 5 1 ]  elements   ==   { 1 3 5 }\n  ")]),e._v("\n  It makes no difference whether the set of elements of a list is taken first\n  and then the set is mapped through a function, or whether the list is first mapped\n  through the same function and then the set of elements is taken. This is the naturality\n  of the\n  "),t("code",[e._v("elements")]),e._v(" function, expressed by\n  "),t("pre",[e._v("        [elements]  dip  map   ==   map  elements\n  ")]),e._v("\n  For example:\n  "),t("pre",[e._v("        [ 3 1 5 1 ]  [dup *]  [elements]  dip  map\n      ==  [ 3 1 5 1 ]  elements  [dup *]  map\n      ==  { 1 3 5 }  [dup *]  map\n      ==  { 1 9 25 }\n  ")]),e._v("\n  and\n  "),t("pre",[e._v("        [ 3 1 5 1 ]  [dup *]  map  elements\n      ==  [ 9 1 25 1 ]  elements\n      ==  { 1 9 25 }\n  ")]),t("p",[e._v("\n    Halfway between lists and sets are multisets or "),t("em",[e._v("bag")]),e._v("s; these have no order\n    but may have repetitions. A "),t("code",[e._v("BAG")]),e._v(" functor would be similar to "),t("code",[e._v("LIST")]),e._v("  and "),t("code",[e._v("SET")]),e._v(", and there would be natural transformations from bags to bags,\n    from lists to bags, and from bags to sets. Currently Joy does not have an implementation\n    of bags.\n  ")]),t("p",[e._v("\n    A list can have as its members other lists, for example lists of integers. Formally\n    these are of type\n    "),t("code",[e._v("LIST(LIST(integer))")]),e._v(". This uses the "),t("code",[e._v("LIST")]),e._v(" functor composed\n    with itself: "),t("code",[e._v("LIST")]),e._v(" \n    "),t("code",[e._v("LIST")]),e._v(". Such a list can be mapped through a function by mapping each\n    sublist, for example\n  ")]),t("pre",[e._v("        [[1 2 3][4 5]]  [[dup *] map]  map   ==   [[1 4 9][16 25]]\n  ")]),e._v("\n  Here the second "),t("code",[e._v("map")]),e._v(" is applied to the whole list, the first or\n  inner "),t("code",[e._v("map")]),e._v(" is applied to the sublists. Alternatively a combinator "),t("kbd",[e._v("mmap")]),e._v("can be defined by\n  "),t("pre",[e._v("        mmap   ==   [map]  cons  map\n  ")]),e._v("\n  and then one can write\n  "),t("pre",[e._v("        [[1 2 3][4 5]]  [dup *]  mmap  ==  [[1 4 9][16 25]]\n  ")]),t("p",[e._v("\n    Whereas a list is one-dimensional, a "),t("em",[e._v("matrix")]),e._v(" is two-dimensional. Matrices\n    can be implemented as lists of lists, and the sublists can be interpreted either\n    as the rows or the columns. One important operation on matrices is the interchange\n    of rows and columns. The "),t("kbd",[e._v("transpose")]),e._v(" operator does just that:\n  ")]),t("pre",[e._v("        [[1 2][3 4]]  transpose   ==   [[1 3][2 4]]\n  ")]),e._v("\n  Transposition is another polymorphic function or natural transformation for\n  matrices. It does not matter whether a matric is first transposed and then mapped\n  elementwise through a function, or whether it is first mapped and then transposed.\n  "),t("pre",[e._v("        [transpose]  dip  mmap   ==   mmap  transpose\n  ")]),t("p",[e._v("\n    The operator "),t("kbd",[e._v("zip")]),e._v(" will transform two lists of the same length into a\n    list of pairs, for example\n  ")]),t("pre",[e._v("        [1 2 3]  [4 5 6]  zip   ==   [[1 4][2 5][3 6]]\n  ")]),e._v("\n  The "),t("code",[e._v("zip")]),e._v(" operator can be defined by\n  "),t("pre",[e._v("        zip   ==   []  cons  cons  transpose\n  ")]),e._v("\n  The "),t("code",[e._v("zip")]),e._v(" function is natural, "),t("code",[e._v("zip")]),e._v("ping the two lists\n  and then "),t("code",[e._v("mmap")]),e._v("ing has the same effect as\n  "),t("code",[e._v("map")]),e._v("ping and then "),t("code",[e._v("zip")]),e._v("ping:\n  "),t("pre",[e._v("        [zip]  dip  mmap   ==   [map]  app2  zip\n  ")]),t("p",[e._v("\n    A similar naturality law holds for the "),t("kbd",[e._v("cartproduct")]),e._v(" operator which produces\n    the "),t("em",[e._v("cartesian product")]),e._v(" of two aggregates which do not have to be of the\n    same type:\n  ")]),t("pre",[e._v("        [cartproduct] dip  mmap   ==   [map] app2  cartproduct\n  ")]),t("p",[e._v("\n    Another useful datatype is that of "),t("em",[e._v("tree")]),e._v("s, also called\n    "),t("em",[e._v("recursive list")]),e._v("s. A tree of integers is either an integer or a list of\n    trees of integer. A "),t("em",[e._v("proper tree")]),e._v(" is a list of trees. The type gives rise\n    to a functor "),t("code",[e._v("TREE")]),e._v(", with the data type "),t("code",[e._v("TREE(integer)")]),e._v(" and\n    mapping functions such as\n    "),t("code",[e._v("TREE(square)")]),e._v(". In Joy the combinator for tree mapping is\n    "),t("kbd",[e._v("treemap")]),e._v(". Most of the operations on lists also apply to proper trees.\n    Reversal can be done by "),t("code",[e._v("reverse")]),e._v(" just at the top level, or by "),t("kbd",[e._v("treereverse")]),e._v("  all the way down into all sublists. Some naturality laws are:\n  ")]),t("pre",[e._v("        [reverse]  dip  treemap   ==   treemap  reverse\n          [treereverse]  dip  treemap   ==   treemap  treereverse\n          [rest]  dip  treemap   ==   treemap  rest\n          [first]  dip  i   ==   treemap  first\n          [[] cons]  dip  treemap   ==   treemap  []  cons\n  ")]),t("p",[e._v("\n    Proper trees can be "),t("kbd",[e._v("treeflatten")]),e._v("ed to form a one-level list. For example\n  ")]),t("pre",[e._v("        [ [1 [2 3] [] 4] [5] ]  treeflatten   ==   [ 1 2 3 4 5 ]\n  ")]),e._v("\n  The "),t("code",[e._v("treeflatten")]),e._v("ing function is a natural transformation between\n  the "),t("code",[e._v("TREE")]),e._v(" and "),t("code",[e._v("LIST")]),e._v(" functors, the order of treeflattening\n  and mapping does not matter:\n  "),t("pre",[e._v("        [treeflatten]  dip  map   ==   treemap  treeflatten\n  ")]),e._v("\n  The following also holds:\n  "),t("pre",[e._v("        treereverse  treeflatten   ==   treeflatten  reverse\n  ")]),t("p",[e._v("\n    A "),t("em",[e._v("bare tree")]),e._v(" is either the empty list "),t("code",[e._v("[]")]),e._v(" or it is a list of\n    bare trees. Formally there is a functor\n    "),t("code",[e._v("BARETREE")]),e._v(", and for (degenerate) functions which can only take "),t("code",[e._v("[]")]),e._v("  as parameters "),t("code",[e._v("BARETREE(f)")]),e._v(" maps bare trees with contained "),t("code",[e._v("[]")]),e._v("  into trees. Proper trees can also be "),t("kbd",[e._v("strip")]),e._v("ped of their leaves to form\n    a bare tree:\n  ")]),t("pre",[e._v("        [ [1 [2 3] [] 4] [5] ]  strip   ==   [ [ [] [] ] [] ]\n  ")]),e._v("\n  The "),t("code",[e._v("strip")]),e._v(" function commutes with "),t("code",[e._v("reverse")]),e._v(" and\n  "),t("code",[e._v("treereverse")]),e._v(":\n  "),t("pre",[e._v("        reverse  strip   ==   strip  reverse\n          treereverse  strip   ==   strip  treereverse\n  ")]),e._v("\n  Once stripped, there is nothing for "),t("code",[e._v("treemap")]),e._v(" to do:\n  "),t("pre",[e._v("        [strip]  dip  treemap   ==   treemap  strip   ==   pop strip\n  ")]),t("h2",[e._v("The LIST monad")]),e._v("\n  This section gives a superficial sketch of monads, another useful concept from category\n  theory. For a fuller exposition see\n  "),t("a",{attrs:{href:"refs.html#{Arbib-Manes75}"}},[e._v("{Arbib-Manes75}")]),e._v(",\n  "),t("a",{attrs:{href:"refs.html#{Asperti-Longo91}"}},[e._v("{Asperti-Longo91}")]),e._v(" and especially\n  "),t("a",{attrs:{href:"refs.html#{Wadler92}"}},[e._v("{Wadler92}")]),e._v(".\n  "),t("p",[e._v("\n    A "),t("em",[e._v("monad")]),t("code",[e._v("M")]),e._v(" over a category consists of a functor from the\n    category to itself, and two natural transformations. The first transformation "),t("code",[e._v("joinM")]),e._v("  takes as argument an object in the target of the square of the functor and gives\n    as value an object in the target of the functor. The second transformation\n    "),t("code",[e._v("unitM")]),e._v(" takes as argument an object in the category and gives as value\n    an object in the target of the functor. The two transformations must satisfy two\n    laws which are expressed in terms of two variants obtained by applying the functor\n    to the two transformations:\n  ")]),t("p",[e._v("\n    From the first transformation one can define a variant by applying the functor to\n    it. This variant is again a natural transformation, it takes as argument an object\n    in the target of the cube of the functor and gives as value an object in the target\n    of the square of the functor. The first transformation or its variant may be composed\n    with the first transformation. The two compositions are again natural transformations,\n    they take as argument an object in the cube of the functor and give as value an\n    object in the target of the functor. The first defining law for monads is that\n    these two compositions must be identical.\n  ")]),t("p",[e._v("\n    Similarly, from the second transformation one can define a variant by applying the\n    functor to it. This variant is again a natural transformation, it takes as argument\n    and value objects in the target of the functor. The second transformation or its\n    variant may be composed with the first transformation. The two compositions take\n    as argument an value objects in the target of the functor. The second defining\n    law for monads is that these two compositions must both be equal to the identity\n    function.\n  ")]),t("p",[e._v("\n    The above will now be illustrated with the "),t("em",[e._v("LIST monad")]),e._v(". Its functor is\n    the "),t("code",[e._v("LIST")]),e._v(" functor. Its first natural transformation is usually called\n    "),t("kbd",[e._v("flatten")]),e._v(", which concatenates a two-level list to produce a single-level\n    list. Its second natural transformation is the unary "),t("kbd",[e._v("unitlist")]),e._v(" operation\n    which takes any argument to produce its singleton list. Here are two examples:\n  ")]),t("pre",[e._v("        [[1 2 3] [peter paul]] flatten  ==  [1 2 3 peter paul]\n          [[1 2 3] [peter paul]] unitlist  ==  [[[1 2 3] [peter paul]]]\n  ")]),e._v("\n  The two required variants are obtained by applying the\n  "),t("code",[e._v("LIST")]),e._v(" functor, as "),t("code",[e._v("map")]),e._v(".\n  "),t("p",[e._v("\n    The variant of the "),t("code",[e._v("flatten")]),e._v(" operator is the polymorphic operator\n  ")]),t("pre",[e._v("        [flatten]  map\n  ")]),e._v("\n  which takes a list of (lists of lists) as argument and concatenates the (list\n  of lists) but leaves the outer level list structure intact. This is an example:\n  "),t("pre",[e._v("        [[[1 2] [3]] [[a] [b]]]  [flatten] map  ==  [[1 2 3] [a b]]\n  ")]),e._v("\n  The first monad law can now be written in Joy notation. It says that there\n  are two equivalent ways of flattening a list of lists of lists to produce a list:\n  "),t("pre",[e._v("        [flatten]  map  flatten   ==   flatten  flatten\n  ")]),t("p",[e._v("\n    The variant of "),t("code",[e._v("unitlist")]),e._v(" is the polymorphic operator\n  ")]),t("pre",[e._v("        [unitlist] map\n  ")]),e._v("\n  which takes a list of elements and produces the list of their unitlists. An\n  example is\n  "),t("pre",[e._v("        [1 2 [3 4]]  [unitlist] map   ==   [[1] [2] [[3 4]]]\n  ")]),e._v("\n  The second monad law can now be written in Joy as\n  "),t("pre",[e._v("        [unitlist] map  flatten   ==   id   ==   unitlist  flatten\n  ")]),t("p",[e._v("\n    As natural transformations both "),t("code",[e._v("flatten")]),e._v(" and\n    "),t("code",[e._v("unitlist")]),e._v(" interact with the "),t("code",[e._v("LIST")]),e._v(" functor operating (as\n    "),t("code",[e._v("map")]),e._v(") on arbitrary functions. There are two further laws that arise.\n    Because these two laws are more general than the preceding ones, they are also\n    more useful:\n  ")]),t("p",[e._v("\n    A list of lists can be mapped at the second level through an arbitrary function using\n    the "),t("code",[e._v("mmap")]),e._v(" combinator, producing another list of lists. That can then\n    be "),t("code",[e._v("flatten")]),e._v("ed to produce a single level list. The same original list\n    of list can first be\n    "),t("code",[e._v("flatten")]),e._v("ed to produce a single level list which can then be mapped\n    at the top level using "),t("code",[e._v("map")]),e._v(". The two results are the same, and in Joy\n    this is expressed as\n  ")]),t("pre",[e._v("        mmap  flatten   ==   [flatten] dip  map\n  ")]),t("p",[e._v("\n    A function may be applied to an argument of any type, and then the\n    "),t("code",[e._v("unitlist")]),e._v(" can be taken. Alternatively the\n    "),t("code",[e._v("unitlist")]),e._v(" can be taken first and then the result can be\n    "),t("code",[e._v("map")]),e._v("ped through the function. That the results are the same can be\n    written in Joy as\n  ")]),t("pre",[e._v("        i  unitlist   ==   [unitlist] dip  map\n  ")]),t("p",[t("a",{attrs:{href:"refs.html#{Wadler92}"}},[e._v("{Wadler92}")]),e._v(" shows that in any monad it is possible\n    to define another natural transformation, "),t("em",[e._v("monadic composition")]),e._v(" which simultaneously\n    resembles function application and function composition. For the "),t("code",[e._v("LIST")]),e._v("  monad it takes as one of its arguments a list and as the other argument a function\n    which yields a list as value. The result is again a list. In Joy it might be defined\n    by\n  ")]),t("pre",[e._v("        bind   ==   map  flatten\n  ")]),e._v("\n  It satisfies the following laws:\n  "),t("pre",[e._v("        [unitlist] dip  bind   ==   i\n          [unitlist] bind   ==   id\n          [K [H] bind] bind  ==  [K] bind  [H] bind\n  ")]),e._v("\n  The first two laws say that "),t("code",[e._v("unitlist")]),e._v(" is a left and right identity\n  for "),t("code",[e._v("bind")]),e._v(", the third says that "),t("code",[e._v("bind")]),e._v(" is associative. The\n  third law is here expressed with program variables "),t("code",[e._v("K")]),e._v(" and "),t("code",[e._v("H")]),e._v(".\n  Alternatively it is expressed by\n  "),t("pre",[e._v("        [bind] cons  concat  bind   ==   [bind] dip  bind\n  ")]),e._v("\n  Wadler makes extensive use of many "),t("code",[e._v("bind")]),e._v("-like functions for monads\n  other than the "),t("code",[e._v("LIST")]),e._v(" monad.\n  "),t("p",[e._v("\n    A very general theory of lists, without the use of category theory, is given in\n    "),t("a",{attrs:{href:"refs.html#{Bird86}"}},[e._v("{Bird86}")]),e._v(". A very readable introduction to the\n    "),t("code",[e._v("LIST")]),e._v(" functor can be found in "),t("a",{attrs:{href:"refs.html#{Spivey89}"}},[e._v("{Spivey89}")]),e._v(".\n    The theory of lists is generalised by "),t("a",{attrs:{href:"refs.html#{Malcolm89}"}},[e._v("{Malcolm89}")]),e._v("    to what have been called rose trees. "),t("a",{attrs:{href:"refs.html#{Meijer-etal91}"}},[e._v("{Meijer-etal91}")]),e._v("    give a comprehensive collection of laws of functional programming using very\n    general functional forms for lists and other data types. "),t("a",{attrs:{href:"refs.html#{Bird-deMoor92}"}},[e._v("{Bird-deMoor92}")]),e._v("    use categories, homomorphisms and algebraic techniques to solve sophisticated\n    optimisation problems in functional programming. It appears that most, and perhaps\n    even all, of the contributions in the above papers can be translated into Joy\n    notation.\n  ")]),t("hr")])}]};n.a=a},upwu:function(e,n,t){var o=t("zn29");"string"==typeof o&&(o=[[e.i,o,""]]),o.locals&&(e.exports=o.locals);t("rjj0")("cea73b4e",o,!1,{sourceMap:!1})},zn29:function(e,n,t){(e.exports=t("FZ+f")(!1)).push([e.i,"p[data-v-fe51c94a]{margin-top:16px;margin-bottom:16px}hr[data-v-fe51c94a]{margin-bottom:16px}pre[data-v-fe51c94a]{margin-bottom:auto}code[data-v-fe51c94a],kbd[data-v-fe51c94a],pre[data-v-fe51c94a]{font-family:Roboto Mono,monospace}",""])}});