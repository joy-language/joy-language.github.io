webpackJsonp([22],{GTVu:function(e,t,n){"use strict";var o=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("article",[n("h1",[e._v("Mathematical foundations of Joy")]),n("i",[e._v(" by Manfred von Thun ")]),e._m(0),e._m(1),n("hr"),n("h1",[e._v("Introduction")]),e._v("\n  Joy programs are built from smaller programs by just two constructors:\n  "),n("em",[e._v("concatenation")]),e._v(" and "),n("em",[e._v("quotation")]),e._v(".\n  "),n("p",[e._v("\n    Concatenation is a binary constructor, and since it is associative it is best written\n    in infix notation and hence no parentheses are required. Since concatenation is\n    the only binary constructor of its kind, in Joy it is best written without an explicit\n    symbol.\n  ")]),n("p",[e._v("\n    Quotation is a unary constructor which takes as its operand a program. In Joy the\n    quotation of a program is written by enclosing it in square brackets. Ultimately\n    all programs are built from atomic programs which do not have any parts.\n  ")]),n("p",[e._v("\n    The semantics of Joy has to explain what the atomic programs mean, how the meaning\n    of a concatenated program depends on the meaning of its parts, and what the meaning\n    of a quoted program is. Moreover, it has to explain under what conditions it is\n    possible to replace a part by an equivalent part while retaining the meaning of\n    the whole program.\n  ")]),e._m(2),n("p",[e._v("\n    However, central to the semantics of Joy is the following:\n  ")]),n("blockquote",[e._v("\n    The concatenation of two programs denotes the composition of the functions denoted\n    by the two programs.\n  ")]),e._v("\n  Function composition is associative, and hence denotation maps the associative syntactic\n  operation of program concatenation onto the associative semantic operation of function\n  composition. The quotation of a program denotes a function which takes any state\n  as argument and yields as value the same state except that the quotation is pushed\n  onto the stack.\n  "),n("p",[e._v("\n    One part of a concatenation may be replaced by another part denoting the same function\n    while retaining the denotation of the whole concatenation.\n  ")]),e._m(3),e._m(4),n("pre",[e._v("        IF          Q1      ==      Q2\n          THEN     P  Q1  R   ==   P  Q2  R\n          AND        [Q1] C   ==     [Q2] C\n  ")]),e._v("\n  The principle is the prime rule of inference for the "),n("em",[e._v("algebra of\n  Joy")]),e._v(" which deals with the equivalence of Joy programs, and hence with the identity\n  of functions denoted by such programs. A few laws in the algebra can be expressed\n  without combinators, but most require one or more combinators for their expression.\n  "),n("p",[e._v("\n    The remainder of this paper is organised as follows. The next sections deal with\n    program concatenation and function composition. The first of these reviews certain\n    algebras called monoids, and homomorphisms between them. In the following section\n    the meaning of Joy programs is shown to be a homomorphism from a syntactic monoid\n    to a semantic monoid. The last of these sections explains the semantic monoid in\n    a little more detail, in particular function composition and the identity function.\n  ")]),n("p",[e._v("\n    The other sections deal with quotations and combinators. The first treats combinators\n    that do not involve the stack, the second those that do. The next section illustrates\n    how these very basic combinators can be used to emulate recursion without explicit\n    definitions. The summary section recapitulates the main conclusions and hints at\n    a connection with category theory.\n  ")]),n("h1",[e._v("Monoids and homomorphisms")]),e._v("\n  The design of Joy was motivated by "),n("a",{attrs:{href:"refs.html#{Quine71}"}},[e._v("{Quine71}")]),e._v(" and\n  "),n("a",{attrs:{href:"refs.html#{Backus78}"}},[e._v("{Backus78}")]),e._v(" who in quite different fields examine\n  how variables of one kind or another can be eliminated and how their work can be\n  done by combinators. In turn their work is based on the pioneers Schönfinkel and\n  Curry. Backus has argued that concepts of programming languages should be selected\n  on the basis of yielding strong and clean mathematical laws. In particular he favours\n  concepts that allow simple algebraic manipulations, where possible replacing variables\n  by combinators or higher order functions. With these goals in mind his research culminated\n  in the language "),n("em",[e._v("FP")]),e._v(". The language Joy offers a very different solution to\n  the same goals. Paulson "),n("a",{attrs:{href:"refs.html#{Paulson92}"}},[e._v("{Paulson92}")]),e._v(' remarked\n  that "Programming and pure mathematics are difficult to combine into one formal framework".\n  Joy attempts this task.\n  '),e._m(5),e._m(6),n("pre",[e._v("        m . x   =   x   =   x . m\n          (x . y) . z   =   x . (y . z)\n  ")]),e._v("\n  For example, these are monoids: the integers with "),n("code",[e._v("0")]),e._v(" as the unit\n  element and addition as the binary operation, or the integers with "),n("code",[e._v("1")]),e._v("as the unit element and multiplication as the binary operation. Two examples from\n  logic are the truth values with falsity as the unit element and disjunction as the\n  binary operation, or truth as the unit element and conjunction as the binary operation.\n  Two examples from set theory are sets with the nullset as the unit element and set\n  union as the binary operation, or the universal set as the unit element and set intersection\n  as the binary operation. It so happens that in the preceding examples the binary\n  operation is commutative, but this is not essential for monoids. Two other examples\n  consists of lists with the empty list as the unit element and concatenation as the\n  binary operation, or strings of characters with the empty string as the unit element\n  and concatenation as the binary operation. Concatenation is "),n("em",[e._v(" not")]),e._v(" commutative.\n  "),n("p",[e._v('\n    Because of the associative law, parentheses are not needed. Also, if there are no\n    other binary operations, the infix operator itself can be omitted and the operation\n    indicated by juxtaposition. Unit elements are often called identity elements, but\n    the word "identity" is already needed with a different meaning in Joy. Unit elements\n    are sometimes called neutral elements, too.\n  ')]),e._m(7),e._m(8),n("pre",[e._v("        h(m)  =  n                      h(x . y)  =  h(x) . h(y)\n  ")]),e._v("\n  In the second equation, the binary operation on the left is that of\n  "),n("code",[e._v("M")]),e._v(", and the one on the right is that of "),n("code",[e._v("N")]),e._v(". One example is\n  the logarithm function which is a homomorphism from the multiplicative monoid onto\n  the additive monoid. Another example of a homomorphism is the "),n("kbd",[e._v("size")]),e._v(" (or\n  length) function on lists which maps the list monoid onto the additive monoid: the\n  size of the empty list is zero, and the size of the concatenation of two lists is\n  the sum of the sizes of the two lists:\n  "),n("pre",[e._v("        log(1)  =  0                    log(x * y)  =  log(x) + log(y)\n          size([])  =  0                  size(x ++ y)  =  size(x) + size(y)\n  ")]),e._v("\n  (In the last two equations, the symbols "),n("code",[e._v("[]")]),e._v(" and\n  "),n("code",[e._v("++")]),e._v(" are used for the empty list and for concatenation.) Other examples\n  are the function which takes a list (or string) as argument and returns the set of\n  its elements. So this function removes duplicates and forgets order. It maps the\n  list monoid onto the set monoid with the nullset as the unit and union as the binary\n  operation.\n  "),e._m(9),n("p",[e._v("\n    In propositional logic the equivalence classes of formulas constitute a Boolean algebra\n    of many elements. A valuation is a homomorphism from that algebra to the two element\n    Boolean algebra of truth values. One can go further: the meaning of a formula is\n    the set of valuations that make it true. The meaning function then is a homomorphism\n    from the Boolean algebra of equivalence classes to the Boolean algebra of sets\n    of valuations. This situation is typical in semantics: the meaning function is\n    a homomorphism. The same holds for Joy - the meaning function is a homomorphism\n    from Joy syntax to Joy semantics.\n  ")]),n("h1",[e._v("A syntactic monoid and a semantic monoid")]),e._v("\n  The "),n("em",[e._v("syntax")]),e._v(" of Joy programs is very simple: the basic building blocks are\n  atomic programs, and larger programs are formed by concatenation as one of the main\n  modes of program construction. Concatenation is associative, and hence no parentheses\n  are required. Also, concatenation is the only binary constructor, so no explicit\n  symbol is required, and hence concatenation can be expressed by juxtaposition. It\n  is useful to have a left and right unit element\n  "),n("kbd",[e._v("id")]),e._v(". Collectively these constitute the syntactic monoid.\n  "),e._m(10),n("p",[e._v("\n    However, the terminology of commands does suggest something useful. Commands, when\n    executed, produce changes. Exactly what is changed depends on the nature of the\n    command. But in the most general terms what changes is the state of a system. In\n    particular the execution of a postfix expression produces changes in the state\n    of a stack. For each change there is a before-state and an after-state. The after-state\n    of one change is the before-state of the next change.\n  ")]),n("p",[e._v("\n    So, changes are essentially functions that take states as arguments and yield states\n    as values. There is only one before-state, so they are functions of one argument.\n    Therefore they can be composed. The composite of two functions can be applied to\n    a state as argument and yields as value the state that is obtained by first applying\n    the one function to the argument and then applying the other function to the resulting\n    value. This is essentially the semantics of Joy: All programs denote functions\n    from states to states.\n  ")]),n("p",[e._v("\n    The state does not have to be the state of a stack. It just so happens that evaluation\n    of postfix expressions is so conveniently done on a stack. But evaluation of expressions\n    is by no means everything. In what follows, the stack is an essential part of the\n    state, but for many purposes it is useful to ignore the whole state altogether.\n  ")]),e._m(11),n("h1",[e._v("Function composition and the identity function")]),e._v("\n  If the "),n("em",[e._v(" programs")]),n("code",[e._v("P")]),e._v(" and "),n("code",[e._v("Q")]),e._v(" denote the same function,\n  then the "),n("em",[e._v(" functions")]),n("code",[e._v("P")]),e._v(" and\n  "),n("code",[e._v("Q")]),e._v(" are "),n("em",[e._v(" identical")]),e._v(". Two functions are identical if for all values\n  in the intersection of their domains they yield the same value. This will be written\n  "),n("pre",[e._v("        P   ==   Q\n  ")]),e._v("\n  The symbol "),n("code",[e._v("==")]),e._v(" will be used to denote the identity of Joy functions.\n  The symbol does not belong to the language Joy but to its metalanguage. The "),n("em",[e._v("identity relation")]),e._v("between functions is clearly "),n("em",[e._v("reflexive")]),e._v(", "),n("em",[e._v("symmetric")]),e._v(" and\n  "),n("em",[e._v("transitive")]),e._v(". Furthermore, identicals are indiscernible in larger contexts\n  such as compositions. Hence "),n("em",[e._v("substitution")]),e._v(" of identicals can be used as a\n  rule of inference:\n  "),n("pre",[e._v("        IF             Q1      ==      Q2\n          THEN        P  Q1  R   ==   P  Q2  R\n  ")]),e._v("\n  The symbol "),n("kbd",[e._v("id")]),e._v(" will be used to denote the "),n("em",[e._v("identity\n  function")]),e._v(". The fact that function composition is associative and that the identity\n  function is a left and right unit is expressed by\n  "),n("pre",[e._v("        (P  Q)  R   ==   P  (Q  R)\n          id  P   ==   P   ==   P  id\n  ")]),e._v("\n  The notation can be used to express what "),n("em",[e._v(" look")]),e._v(" like identities of\n  numbers; for example\n  "),n("pre",[e._v("        2  3  +   ==   5\n  ")]),e._v("\n  expresses that the composition of the three "),n("em",[e._v(" functions")]),e._v(" on the left\n  is identical with the one "),n("em",[e._v(" function")]),e._v(" on the right. On the left, the first\n  two functions push the "),n("em",[e._v(" numbers")]),e._v(" 2 and 3 onto the stack, and the third replaces\n  them by their sum. On the right, the function pushes the "),n("em",[e._v(" number")]),e._v(" 5. The\n  left and the right are defined for all stacks as arguments and yield the same stack\n  as value. Hence the left and the right are identical.\n  "),e._m(12),e._m(13),e._m(14),n("pre",[e._v("        (2  3)  +   ==   2  (3  +)\n  ")]),e._v("\n  On the left the "),n("code",[e._v("+")]),e._v(" takes two parameters supplied by\n  "),n("code",[e._v("(2 3)")]),e._v(". On the right "),n("code",[e._v("+")]),e._v(" is given one parameter, "),n("code",[e._v("3")]),e._v(".\n  The resulting function "),n("code",[e._v("(3 +)")]),e._v(" expects one parameter to which it will\n  add "),n("code",[e._v("3")]),e._v(". Because of associativity the two sides are identical and hence\n  no parentheses are required.\n  "),n("p",[e._v("\n    Let "),n("code",[e._v("P")]),e._v(" be a program which pushes "),n("tt",[e._v("m")]),e._v(" values onto the stack.\n    Let "),n("code",[e._v("Q")]),e._v(" be a program which expects "),n("tt",[e._v("n")]),e._v(" values on the stack, "),n("tt",[e._v("m")]),e._v("  <= "),n("tt",[e._v("n")]),e._v(". Now consider their concatenation "),n("code",[e._v("P\n    Q")]),e._v(". Of the "),n("tt",[e._v("n")]),e._v(" expected by "),n("code",[e._v("Q")]),e._v(", "),n("tt",[e._v("n")]),e._v(" will be supplied\n    by "),n("code",[e._v("P")]),e._v(". So the program "),n("code",[e._v("P Q")]),e._v(" only expects "),n("tt",[e._v("n -\n    m")]),e._v(" values on the stack.\n  ")],1),n("hr"),e._v("\n  +++HERE+++ assoc and curry\n  "),n("hr"),e._m(15),e._m(16),e._m(17),n("pre",[e._v("        0  +   ==   id                  1  *   ==   id\n          []  concat   ==   id            []  swap  concat   ==   id\n          false  or   ==   id             true  and   ==   id\n          dup  and   ==   id              dup  or   ==   id\n          swap  swap   ==   id            dup  pop   ==   id\n          not  not   ==   id              reverse  reverse   ==   id\n          succ  pred   ==   id            pred  succ   ==   id\n  ")]),e._v("\n  Note that no variables were needed to express these laws.\n  "),e._m(18),n("pre",[e._v("        l  P   ==   l                   P  r   ==   r\n  ")]),e._v("\n  Since function composition is not commutative, the two zero elements are not\n  identical. In Joy the left zero "),n("code",[e._v("l")]),e._v(" is the\n  "),n("kbd",[e._v("abort")]),e._v(" operator, it ignores any program following it. The right zero "),n("code",[e._v("r")]),e._v("is the "),n("kbd",[e._v("clearstack")]),e._v(" operator, it empties the stack and hence ignores any\n  calculations that might have been done before. The two operators have some theoretical\n  interest, and they are occasionally useful.\n  "),n("h1",[e._v("Quotation, dequotation and combinators")]),e._v("\n  Any program enclosed in square brackets is called a "),n("em",[e._v("quoted\n  program")]),e._v(" or "),n("em",[e._v("quotation")]),e._v(". The length or "),n("code",[e._v("size")]),e._v(" of the quotation\n  "),n("code",[e._v("[5]")]),e._v(" is "),n("code",[e._v("1")]),e._v(", and the size of the quotation "),n("code",[e._v("[2 3 +]")]),e._v("is "),n("code",[e._v("3")]),e._v(". However, as noted earlier, the two programs inside the brackets\n  denote the same function. What this shows is that we cannot substitute their quotations\n  for each other:\n  "),n("pre",[e._v("        [5]  size   =/=   [2 3 +]  size\n  ")]),e._v("\n  What forbids the substitution is the quotation - by the square brackets. So\n  quotations produce opaque contexts, quotation is an intensional constructor.\n  "),e._m(19),e._m(20),n("pre",[e._v("        [P]  i   ==   P\n  ")]),e._v("\n  For example, each of the following four programs compute the same function\n  - the one which takes any stack as argument and returns as value another stack which\n  is like the argument stack but has the number "),n("code",[e._v("5")]),e._v(" pushed on top.\n  "),n("pre",[e._v("         2  3  +                         5\n          [2  3  +] i                     [5] i\n  ")]),e._v("\n  If the program "),n("code",[e._v("P")]),e._v(" computes the identity function, then the effect\n  of applying the "),n("code",[e._v("i")]),e._v(" combinator is that of the identity function:\n  "),n("pre",[e._v("        [id]  i   ==   id               []  i   ==   id\n  ")]),e._v("\n  Another law is this:\n  "),n("pre",[e._v("        i  ==  []  cons  i  i\n  ")]),e._m(21),n("p",[e._v("\n    Hence\n  ")]),n("pre",[e._v("        IF       P       ==    Q\n          THEN    [P]  i   ==   [Q]  i\n  ")]),e._v("\n  Suppose now that a quoted program, "),n("code",[e._v("[P]")]),e._v(", is on top of the stack.\n  It could then be executed with the "),n("code",[e._v("i")]),e._v(" combinator. But it could also be\n  manipulated as a passive data structure first. For example, one could push the quotation\n  "),n("code",[e._v("[i]")]),e._v(" and then use the "),n("kbd",[e._v("cons")]),e._v(" operator to insert "),n("code",[e._v("[P]")]),e._v("into\n  "),n("code",[e._v("[i]")]),e._v(" to give "),n("code",[e._v("[[P] i]")]),e._v(". What happens if this is executed by\n  the "),n("code",[e._v("i")]),e._v(" combinator? The internal\n  "),n("code",[e._v("[P]")]),e._v(" quote is pushed, and then the internal "),n("code",[e._v("i")]),e._v(" combinator\n  is executed. So the net effect is that of executing\n  "),n("code",[e._v("P")]),e._v(".\n  "),n("p",[e._v("\n    Hence\n  ")]),n("pre",[e._v("        [i]  cons  i   ==   i\n  ")]),e._v("\n  Note that it has been possible to state this law without reference to the\n  quoted program "),n("code",[e._v("[P]")]),e._v(". But it may help to spell out a consequence:\n  "),n("pre",[e._v("        [P]  [i]  cons  i   ==   [[P] i]  i   ==   [P]  i   ==   P\n  ")]),e._m(22),n("pre",[e._v("        [P]  [Q]  b   ==   P  Q\n  ")]),e._v("\n  It follows that the "),n("code",[e._v("b")]),e._v(" combinator actually dequotes both of its\n  parameters, and hence either or both can be replaced by an equivalent program:\n  "),n("pre",[e._v("        IF       P1  ==  P2     AND    Q1  ==  Q2\n          THEN    [P1]  [Q1]  b   ==   [P2]  [Q2]  b\n  ")]),e._v("\n  If both programs compute the identity function, then the effect of the\n  "),n("code",[e._v("b")]),e._v(" combinator is the identity function. If either of the two programs\n  computes the identity function, then the effect is the same as that of executing\n  the other, which is the same as applying the\n  "),n("code",[e._v("i")]),e._v(" combinator to the other:\n  "),n("pre",[e._v("        []  []  b   ==   id\n          []  b   ==   i\n          []  swap  b   ==   i\n  ")]),e._v("\n  The second equation could be reversed, and this shows that the\n  "),n("code",[e._v("i")]),e._v(" combinator could be "),n("em",[e._v(" defined")]),e._v(" in terms of the\n  "),n("code",[e._v("b")]),e._v(" combinator.\n  "),e._m(23),n("pre",[e._v("        [P]  [Q]  concat  i   ==   P  Q   ==   [P]  [Q]  b\n  ")]),e._v("\n  But the two quoted programs do not have to be pushed immediately before the\n  concatenation or the application of the "),n("code",[e._v("b")]),e._v(" combinator. Instead they could\n  have been constructed from smaller parts or extracted from some larger quotation.\n  Hence the more general law:\n  "),n("pre",[e._v("        concat  i   ==   b\n  ")]),e._v("\n  The equation could be reversed, hence the "),n("code",[e._v("b")]),e._v(" combinator could\n  be "),n("em",[e._v(" defined")]),e._v(" in terms of the "),n("code",[e._v("i")]),e._v(" combinator. The "),n("em",[e._v(" names")]),n("code",[e._v("i")]),e._v(" and "),n("code",[e._v("b")]),e._v(" of the two combinators have been chosen because\n  of their similarity to the "),n("em",[e._v("I combinator")]),e._v(" and "),n("em",[e._v("B combinator")]),e._v(" in "),n("em",[e._v("combinatory\n  logic")]),e._v(". The standard text is "),n("a",{attrs:{href:"refs.html#{Curry58}"}},[e._v("{Curry58}")]),e._v(", but\n  good expositions are to be found in many other books, for example "),n("a",{attrs:{href:"refs.html#{Burge75}"}},[e._v("{Burge75}")]),e._v(".\n  "),n("h1",[e._v("Stack oriented combinators")]),e._v("\n  The two previous combinators require one or two quoted programs as parameters, but\n  the parameters merely have to be in an agreed place, they do not need to be on a\n  stack. There are several combinators which only make sense if the data are located\n  on a stack.\n  "),e._m(24),e._m(25),n("pre",[e._v("        2  3  4  [+]  dip  ==   5  4\n  ")]),e._v("\n  If a program computes the identity function, then the effect of applying the\n  "),n("code",[e._v("dip")]),e._v(" combinator is to compute the identity function:\n  "),n("pre",[e._v("        [id]  dip   ==   id             []  dip   ==   id\n  ")]),e._v("\n  Suppose a program "),n("code",[e._v("[P]")]),e._v(" is on top of the stack, and it is first\n  duplicated and then the copy executed with "),n("code",[e._v("dip")]),e._v(" just below the original\n  "),n("code",[e._v("[P]")]),e._v(". Now the original has been restored, but suppose it is now popped\n  explicitly. The net effect was the same as executing just the original "),n("code",[e._v("[P]")]),e._v("with the\n  "),n("code",[e._v("i")]),e._v(" combinator:\n  "),n("pre",[e._v("        i   ==   dup  dip  pop\n  ")]),e._v("\n  Suppose that there are two programs "),n("code",[e._v("[P]")]),e._v(" and\n  "),n("code",[e._v("[Q]")]),e._v(" on top of the stack, with "),n("code",[e._v("[Q]")]),e._v(" on top. It is required\n  to execute "),n("code",[e._v("[P]")]),e._v(" while saving\n  "),n("code",[e._v("[Q]")]),e._v(" above. One way to do that is this: First push\n  "),n("code",[e._v("[i]")]),e._v(". Now "),n("code",[e._v("[Q]")]),e._v(" is the second element. Executing "),n("code",[e._v("dip")]),e._v("will save "),n("code",[e._v("[Q]")]),e._v(" and execute\n  "),n("code",[e._v("[i]")]),e._v(" on the stack which now has "),n("code",[e._v("[P]")]),e._v(" on the top. That amounts\n  to executing "),n("code",[e._v("[P]")]),e._v(", and after that\n  "),n("code",[e._v("[Q]")]),e._v(" is restored.\n  "),e._m(26),n("pre",[e._v("        b   ==   [i]  dip  i\n  ")]),e._v("\n  The last two equations show that the "),n("code",[e._v("dip")]),e._v(" combinator could be\n  used to "),n("em",[e._v(" define")]),e._v(" both the "),n("code",[e._v("i")]),e._v(" combinator and the "),n("code",[e._v("b")]),e._v("combinator. The reverse is not possible.\n  "),e._m(27),n("pre",[e._v("        b   ==   [dup dip pop]  dip  dup  dip  pop\n  ")]),e._v("\n  The substitution of the unquoted occurrence is unproblematic. But the other\n  substitution requires comment. Quoted occurrences can be substituted only in a context\n  of dequotation, and in this case such a context is given by the "),n("code",[e._v("dip")]),e._v("combinator.\n  "),e._m(28),n("pre",[e._v("        dip  i   ==   swap  b           b   ==   swap  dip  i\n                                          b   ==   swap  dip  dup  dip  pop\n  ")]),n("p",[e._v("\n    Function composition is associative, and hence the following holds:\n  ")]),n("pre",[e._v("        [P]  [Q]  b  [R]  i   ==   [P]  i  [Q]  [R]  b\n  ")]),e._v("\n  To eliminate the three quotations from this equation observe that they can\n  be written on the left of both sides provided that the\n  "),n("code",[e._v("b")]),e._v(" combinator and the "),n("code",[e._v("i")]),e._v(" combinator are applied appropriately.\n  For the left side this is easy:\n  "),n("pre",[e._v("        [P]  [Q]  b  [R]  i   ==   [P]  [Q]  [R]  [b] dip i\n  ")]),e._v("\n  For the right side it is a little harder since the "),n("code",[e._v("i")]),e._v(" combinator\n  has to be applied to "),n("code",[e._v("[P]")]),e._v(" which is obscured not by one but two other\n  quotations. The "),n("code",[e._v("dip")]),e._v(" combinator has to be used on itself in this case,\n  as follows:\n  "),n("pre",[e._v("        [P]  i  [Q]  [R]  b   ==   [P]  [Q]  [R]  [[i] dip]  dip  b\n  ")]),e._v("\n  Combining the two right hand sides and cancelling the common three quotations\n  we obtain the following to expressing the associativity of function composition:\n  "),n("pre",[e._v("        [b]  dip  i   ==   [[i] dip]  dip  b\n  ")]),e._v("\n  In this law we can even replace the "),n("code",[e._v("i")]),e._v(" combinator and the\n  "),n("code",[e._v("b")]),e._v(" combinator in accordance with earlier definitions:\n  "),n("pre",[e._v("        [swap  dip  dup  dip  pop]  dip  dup  dip  pop\n     ==   [[dup  dip  pop]  dip]  dip  swap  dip  dup  dip  pop\n  ")]),e._v("\n  It is possible to cancel the final "),n("code",[e._v("pop")]),e._v(" on both sides, but it\n  is not possible to cancel the prefinal "),n("code",[e._v("dip")]),e._v(" on both sides. This unlikely\n  law also expresses the associativity of function composition. But the most elegant\n  way of expressing the associativity is by using a variant of the "),n("code",[e._v("dip")]),e._v("combinator, called\n  "),n("kbd",[e._v("dipd")]),e._v(", which might be defined by\n  "),n("pre",[e._v("        dipd   ==   [dip]  cons  dip\n  ")]),e._v("\n  Then the associativity can be expressed by\n  "),n("pre",[e._v("        [b]  dip  i   ==   [i]  dipd  b\n  ")]),e._v("\n  (\n  "),n("a",{attrs:{href:"refs.html#{Henson87}"}},[e._v("{Henson87}")]),e._v(" criticises presentations of FP-systems,\n  originally due to\n  "),n("a",{attrs:{href:"refs.html#{Backus78}"}},[e._v("{Backus78}")]),e._v(" in that they give no law to this effect\n  although they use it in proofs.)\n  "),e._m(29),e._m(30),e._m(31),n("pre",[e._v("        k   ==   [pop]  dip  i\n          w   ==   [dup]  dip  i\n          c   ==   [swap] dip  i\n  ")]),n("h1",[e._v("More general laws")]),e._v("\n  Suppose that there is a quoted program "),n("code",[e._v("[P]")]),e._v(" on top of the stack. This\n  could now be executed by some combinator, say\n  "),n("code",[e._v("C")]),e._v(". Alternatively, one could push the quotation\n  "),n("code",[e._v("[C]")]),e._v(" and then use the "),n("code",[e._v("cons")]),e._v(" operator to insert the earlier\n  "),n("code",[e._v("[P]")]),e._v(" into the later quotation, and this produces "),n("code",[e._v("[[P] C]")]),e._v(".\n  This of course may be executed by the\n  "),n("code",[e._v("i")]),e._v(" combinator. When that happens the inner\n  "),n("code",[e._v("[P]")]),e._v(" is pushed, thus partly undoing the "),n("code",[e._v("cons")]),e._v(" operation.\n  But then "),n("code",[e._v("C")]),e._v(" will be executed. The net effect is the same as the earlier\n  alternative. So we have: For all operators or combinators "),n("code",[e._v("C")]),n("pre",[e._v("        [C]  cons  i   ==   C\n  ")]),e._v("\n  It should be remarked that this theorem also holds for operators, say\n  "),n("code",[e._v("O")]),e._v(", instead of combinators "),n("code",[e._v("C")]),e._v(".\n  "),e._m(32),n("pre",[e._v("        [i]  cons  C   ==   C\n  ")]),n("p",[e._v("\n    The two laws above may be combined: for all combinators C\n  ")]),n("pre",[e._v("        [i]  cons  C   ==   [C]  cons  i\n  ")]),e._m(33),n("pre",[e._v("        [i]  cons  cons  C   ==   C\n          [C]  cons  cons  i   ==   C\n          [i]  cons  cons  C   ==   [C]  cons cons  i\n  ")]),e._v("\n  The principle generalises to combinators with at least three quoted parameters,\n  by allowing three "),n("code",[e._v("cons")]),e._v(" operations to occur.\n  "),e._m(34),e._m(35),e._m(36),n("pre",[e._v("        [[i] cons]  app1  C1   ==   C1\n          [[i] cons]  app2  C2   ==   C2\n          [[i] cons]  app3  C3   ==   C3\n  ")]),e._v("\n  To illustrate for a combinator C3:\n  "),n("pre",[e._v("         [P]      [Q]      [R]    [[i] cons]  app3  C3\n     ==   [[P] i]  [[Q] i]  [[R] i]                   C3\n     ==    [P]      [Q]      [R]                      C3\n  ")]),e._v("\n  Computationally it is of course pointless to replace a quotation such as "),n("code",[e._v("[P]")]),e._v("by "),n("code",[e._v("[[P] i]")]),e._v(" if the quotations are being used as parameters for a combinator.\n  But the replacements are invaluable in a Joy interpreter written in Joy. This interpreter\n  is essentially a complex combinator, appropriately called "),n("kbd",[e._v("joy")]),e._v(", and it\n  has to behave just like the "),n("code",[e._v("i")]),e._v(" combinator. In the definition of the "),n("code",[e._v("joy")]),e._v("combinator, the implementation of all combinators uses the above mapping combinators\n  but with\n  "),n("code",[e._v("[[joy] cons]")]),e._v(" instead of "),n("code",[e._v("[[i] cons]")]),e._v(".\n  "),n("h1",[e._v("Elimination of Definitions")]),e._v("\n  One of the problems of large pieces of software concerns the complexity of interdependent\n  parts and the need to make interfaces lean. To some extent this is a matter of information\n  hiding, and programming languages achieve this in various ways. Most have local symbols\n  such as formal parameters of functions and local program variables of procedures.\n  Many have full block structure allowing declarations of functions and procedures\n  to be nested and hence invisible from the outside. Some have modules or other compilation\n  units which allow further information hiding in larger program components. Joy approaches\n  the problem in a different way -- the information that needs to be hidden is minimised\n  in the first place. Mostly the problem arises from declarations of named functions\n  and procedures and their named formal parameters.\n  "),n("p",[e._v("\n    There are several reasons why one might want to declare a function, because\n  ")]),e._m(37),n("p",[e._v("\n    The third reason is always valid. In Joy the second reason is much less compelling,\n    and the first has almost no force at all.\n  ")]),n("p",[e._v("\n    Joy has a large number of combinators which permit computation of anonymous functions\n    which are normally defined recursively. It also has combinators that permit repeated\n    calls of such functions in some related patterns. Joy programs which use suitable\n    combinators to allow the computation of anonymous functions with anonymous formal\n    parameters.\n  ")]),e._m(38),n("pre",[e._v("    LET  factorial(n)  =  if n = 0 then 1 else n * factorial(n - 1)\n       IN  factorial(5)\n  ")]),e._v("\n  The call in the second line should return "),n("code",[e._v("120")]),e._v(". Joy has a number\n  of ways of doing essentially the same computation without introducing the "),n("em",[e._v(" name")]),n("code",[e._v("factorial")]),e._v(" and without introducing the "),n("em",[e._v(" name")]),e._v(" of the formal parameter\n  "),n("code",[e._v("n")]),e._v(". Several of these ways are still modelled on the recursive definition\n  and have approximately the same length. Two of them are based on the fact that the\n  definition has the pattern of "),n("em",[e._v("linear recursion")]),e._v(", indeed "),n("em",[e._v("primitive recursion")]),e._v(".\n  As in all languages the use of\n  "),n("em",[e._v("accumulating parameter")]),e._v("s can avoid the recursion altogether, but that is\n  not the point here.\n  "),e._m(39),n("p",[e._v("\n    This is the program:\n  ")]),n("pre",[e._v("1           5\n  2           [  [pop  0  =]\n  3              [pop  pop  1]\n  4              [  [dup  1  -]  dip\n  5                 dip  i\n  6                 *  ]\n  7              ifte  ]\n  8           dup  i\n  ")]),e._m(40),e._m(41),e._m(42),e._m(43),e._m(44),e._m(45),e._m(46),e._m(47),n("pre",[e._v("        5  [1]  [*]  primrec\n  ")]),e._v("\n  As mentioned before, even the use of recursion can be eliminated in favour\n  of a more efficient loop combinator which uses an accumulating parameter.\n  "),n("h1",[e._v("Summary")]),e._v("\n  This paper has attempted to explain the theoretical foundations of the language\n  Joy. Much of the semantics is summarised by observing that the following are true:\n  "),n("pre",[e._v("        2  3  +   ==   7  2 -\n          dup  +   ==   2  *\n          dip  i   ==   swap  b\n  ")]),e._v("\n  The first "),n("em",[e._v(" seems")]),e._v(" to express the identity of numbers. The second "),n("em",[e._v(" seems")]),e._v("to express the identity of functions which both double a given number which they\n  expect on the stack. The third "),n("em",[e._v("\n  seems")]),e._v(" to express the identity of functionals, or second order functions which\n  take two first order functions as parameter and compose them.\n  "),n("p",[e._v("\n    While these readings are sometimes helpful, the unity of Joy semantics really forces\n    a different interpretation. All three equations express identity of Joy functions\n    which take one argument stack and yield one value stack.\n  ")]),e._m(48),e._m(49),n("hr")])};o._withStripped=!0;var i={render:o,staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("em",[this._v("Abstract:")]),this._v(" Joy is a functional programming language which is not based\n    on the application of functions to arguments but on the composition of functions.\n    This paper describes the theoretical basis of the language. The denotation of Joy\n    programs maps a syntactic monoid of program concatenation to a semantic monoid\n    of function composition. Instead of lambda abstraction Joy uses program quotation,\n    and higher order functions can be simulated by first order functions which dequote\n    quoted programs.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("em",[this._v("Keywords:")]),this._v(" functional programming, syntactic and semantic monoids, function\n    composition, quotation and dequotation of programs, combinators, elimination of\n    recursive definitions.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    Joy programs denote functions which take one argument and yield one value. The argument\n    and the value are "),t("em",[this._v("state")]),this._v("s consisting of at least three components. The\n    principal component is a\n    "),t("em",[this._v("stack")]),this._v(", and the other components are not needed here. Much of the detail\n    of the semantics of Joy depends on specific properties of programs.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    One quoted program may be replaced by another denoting the same function only in\n    a context where the quoted program will be dequoted by being executed. Such contexts\n    are provided by the\n    "),t("em",[this._v("combinator")]),this._v("s of Joy. These denote functions which behave like higher order\n    functions in other languages.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    The above may be summarised as follows: Let "),n("code",[e._v("P")]),e._v(",\n    "),n("code",[e._v("Q1")]),e._v(", "),n("code",[e._v("Q2")]),e._v(" and "),n("code",[e._v("R")]),e._v(" be programs, and let "),n("code",[e._v("C")]),e._v("  be a combinator. Then this principle holds:\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    Much of the elegance of Joy is due to the simple algebraic structure of its syntax\n    and the simple algebraic structure of its semantics and to the fact that the two\n    structures are so similar. In particular, the two structures are "),t("em",[this._v("monoid")]),this._v("s\n    and the meaning function which maps syntax into semantics is a "),t("em",[this._v("homomorphism")]),this._v(".\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    Monoids and homomorphisms are familiar from abstract algebra. A "),n("em",[e._v("\n    monoid")]),n("code",[e._v("M")]),e._v(" consists of a nonempty set "),n("code",[e._v("{m, m1,\n    m2 ...}")]),e._v(" including a special element "),n("code",[e._v("m")]),e._v(", and a binary operation,\n    written, say, as infix period "),n("code",[e._v('"."')]),e._v(". The special element has to be a\n    left and right "),n("em",[e._v("unit element")]),e._v(" for the binary operation, and the binary operation\n    has to be\n    "),n("em",[e._v("associative")]),e._v(". In symbols, for all "),n("code",[e._v("x")]),e._v(",\n    "),n("code",[e._v("y")]),e._v(" and "),n("code",[e._v("z")]),e._v(" from the set,\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    Unit elements should be distinguished from "),t("em",[this._v("zero element")]),this._v("s, which behave\n    the way the number "),t("code",[this._v("0")]),this._v(" interacts with multiplication: a product containing\n    a zero factor is equal to zero. In logic falsity is the zero element for conjunction,\n    and truth is the zero element for disjunction. For sets the nullset is the zero\n    element for intersection, and the universal set is the zero element for union.\n    In commutative monoids there is always at most one zero element.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    Let "),n("code",[e._v("M")]),e._v(" over "),n("code",[e._v("{m m1 ..}")]),e._v(" and "),n("code",[e._v("N")]),e._v(" over\n    "),n("code",[e._v("{n n1 ..}")]),e._v(" be two monoids. A function "),n("code",[e._v("h")]),e._v(" from\n    "),n("code",[e._v("{m m1 ..}")]),e._v(" to "),n("code",[e._v("{n n1 ..}")]),e._v(" is called a "),n("em",[e._v("\n    homomorphism")]),e._v(" if and only if it maps unit elements onto unit elements and commutes\n    with the binary operation:\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    Homomorphisms can be defined over other algebras which are not monoids. Examples\n    are groups, rings, fields and Boolean algebras. They are studied in universal algebra\n    and in category theory. One particular homomorphism can only be described as mind-blowing:\n    this is Gödel's arithmetisation of syntax - all syntactic operations on formulas\n    of a theory are mapped onto corresponding arithmetic operations on their Gödel\n    numbers. (See for example\n    "),t("a",{attrs:{href:"refs.html#{Mendelson64}"}},[this._v("{Mendelson64}")]),this._v(".)\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    Now to the "),t("em",[this._v("semantics")]),this._v(". In the introduction it was said that Joy uses postfix\n    notation for the evaluation of arithmetic expressions. To add two numbers they\n    are pushed onto a stack and then replaced by their sum. This terminology is helpful\n    but can be misleading in several ways. The phrasing suggest a procedural or imperative\n    interpretation: Joy programs consist of commands such as push this, push that,\n    pop these and push their sum. But there is nothing procedural about Joy, as described\n    here it is a purely functional language.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    The operation of "),t("em",[this._v("function composition")]),this._v(" is associative and there is a left\n    and right unit element, the "),t("em",[this._v("identity\n    function")]),this._v(". Collectively they comprise the semantic monoid. The meaning function\n    maps a syntactic monoid onto a semantic monoid. The concatenation of two programs\n    denotes the composition of the functions denoted by the two programs, and the unit\n    element of concatenation denotes the unit element of composition.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    But it is important to be quite clear what the equation says. Each of the four symbols\n    "),n("code",[e._v("2")]),e._v(", "),n("code",[e._v("3")]),e._v(", "),n("code",[e._v("+")]),e._v(" and\n    "),n("code",[e._v("5")]),e._v(" denotes a function which takes a stack as argument and yields a\n    stack as value. The three "),n("em",[e._v(" numerals")]),n("code",[e._v("2")]),e._v(",\n    "),n("code",[e._v("3")]),e._v(" and "),n("code",[e._v("5")]),e._v(" denote "),n("em",[e._v(" functions")]),e._v(" which are defined\n    for all argument stacks. They yield as values other stacks which are like the argument\n    stacks except that a new "),n("em",[e._v(" number")]),e._v(", 2, 3 and 5 has been pushed on top.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    The symbol "),n("code",[e._v("+")]),e._v(" does "),n("em",[e._v(" not")]),e._v(" denote a "),n("em",[e._v("\n    binary")]),e._v(" function of two numbers, but like all Joy functions it takes one argument\n    only. That argument has to be a stack whose top two elements are numbers. The value\n    returned is another stack which has the top two numbers replaced by their sum.\n    It follows that the above equation does "),n("em",[e._v(" not")]),e._v(" express the identity of numbers\n    but the identity of "),n("em",[e._v(" functions")]),e._v(".\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    The associativity of composition has as a consequence about\n    "),t("em",[this._v("currying")]),this._v(": that there is no difference between standard and curried operators.\n    Consider the example\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    In the development of mathematics an explicit notation for the number\n    "),t("code",[this._v("0")]),this._v(" has been a rather recent innovation. The symbol enables one to say\n    more than just that "),t("code",[this._v("0")]),this._v(" is a unit element for addition. Similarly, in\n    the algebra of functions an explicit symbol for the identity function makes it\n    possible to state many laws. This is particularly true for the functions in Joy.\n    The following are some examples:\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    In arithmetic "),n("code",[e._v("0")]),e._v(" and "),n("code",[e._v("1")]),e._v(" are unit elements for addition\n    and multiplication, so adding "),n("code",[e._v("0")]),e._v(" or multiplying by "),n("code",[e._v("1")]),e._v(" have\n    no effect. For lists the empty list is a unit element, so concatenation on the\n    left or the right has no effect. Similarly in logic, falsity and truth are unit\n    elements for disjunction and conjunction, so disjoining with falsity and conjoining\n    with truth make no difference. Also in logic, disjunction and conjunction are idempotent,\n    so disjoining or conjoining with a\n    "),n("kbd",[e._v("dup")]),e._v("licate yields the original. For any stack it holds that\n    "),n("kbd",[e._v("swap")]),e._v("ping the top two elements twice has no net effect, and that duplicating\n    the top element and then "),n("kbd",[e._v("pop")]),e._v("ping off the duplicate has no net effect.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    There are many more laws: double negation has no net effect, reversing a sequence\n    twice just leaves the original, and taking the successor and the predeccessor of\n    a number - in either order - produces no net effect. In the "),t("em",[this._v("algebra of Joy")]),this._v("  these are expressed by the following:\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    The identity function is a left and right unit element with respect to function composition.\n    It is appropriate to remark here that there is also a "),n("em",[e._v("left zero element")]),e._v("  and there is a "),n("em",[e._v("right zero\n    element")]),e._v(". Two such elements "),n("code",[e._v("l")]),e._v(" and "),n("code",[e._v("r")]),e._v(" satisfy the following\n    for all programs "),n("code",[e._v("P")]),e._v(":\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    However, there are contexts where substitution is permissable across quotations.\n    These are contexts where the content of the quote is not treated as a passive datum\n    but as an active program. In Joy such treatment is due to "),t("em",[this._v("combinator")]),this._v("s\n    which in effect dequote one or more of their parameters.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    The "),n("kbd",[e._v("i")]),e._v(" combinator expects a quoted program on top of the stack. It pops\n    that program and executes it. So, if the quoted program "),n("code",[e._v("[P]")]),e._v(" has just\n    been pushed onto the stack, then the\n    "),n("code",[e._v("i")]),e._v(" combinator will execute "),n("code",[e._v("P")]),e._v(":\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    Two programs "),t("code",[this._v("P")]),this._v(" and "),t("code",[this._v("Q")]),this._v(" may look very different - for example,\n    they may differ in their sizes. But it could be that the compute the same function.\n    In that case the dequotations of their quotations also compute the same function:\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    The "),n("code",[e._v("i")]),e._v(" combinator is only one of many. Another is the\n    "),n("kbd",[e._v("b")]),e._v(" combinator which expects two quoted programs on top of the stack.\n    It pops them both and then executes the program that was second on the stack and\n    continues by executing the program that was on top of the stack. So, in the special\n    case where two programs\n    "),n("code",[e._v("[P]")]),e._v(" and "),n("code",[e._v("[Q]")]),e._v(" have just been pushed onto the stack, the\n    "),n("code",[e._v("b")]),e._v(" combinator will execute them in the order in which they have been\n    pushed:\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    Quotations are sequences, and sequences can be concatenated. In Joy strings, lists\n    and, more generally, quotations can be concatenated with the "),n("kbd",[e._v("concat")]),e._v("  operator. If "),n("code",[e._v("[P]")]),e._v(" and\n    "),n("code",[e._v("[Q]")]),e._v(" have just been pushed, then they can be concatenated to become\n    "),n("code",[e._v("[P Q]")]),e._v(". The resultant concatenation can be executed by the "),n("code",[e._v("i")]),e._v("  combinator. The net effect is that of executing the two programs, and that is also\n    achieved by applying the\n    "),n("code",[e._v("b")]),e._v(" combinator:\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    Sometimes it is necessary to manipulate the stack not at the top but just below the\n    top. That is what the "),n("kbd",[e._v("dip")]),e._v(" combinator is for. It is behaves like the\n    "),n("code",[e._v("i")]),e._v(" combinator by executing one quotation on top of the stack, except\n    that it leaves the item just below the quotation unchanged. In detail, it expects\n    a program\n    "),n("code",[e._v("[P]")]),e._v(" and below that another item "),n("code",[e._v("X")]),e._v(". It pops both, saves\n    "),n("code",[e._v("X")]),e._v(", executes "),n("code",[e._v("P")]),e._v(" and then restores\n    "),n("code",[e._v("X")]),e._v(".\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    For example, in the following the saved and restored item is "),t("code",[this._v("4")]),this._v(":\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    Suppose further that it is now required to execute "),n("code",[e._v("[Q]")]),e._v(", and that is\n    easily done with the "),n("code",[e._v("i")]),e._v(" combinator. The net effect of all this is the\n    same as executing first "),n("code",[e._v("[P]")]),e._v(" and then "),n("code",[e._v("[Q]")]),e._v(", which could\n    have been done with the\n    "),n("code",[e._v("b")]),e._v(" combinator. Hence\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    The last two equations also serve to illustrate algebraic manipulation of Joy programs.\n    In the last equation the "),t("code",[this._v("i")]),this._v(" combinator occurs twice, once quoted\n    and once unquoted. Both occurrences can be replaced in accordance with the previous\n    equation, and this yields\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    Again suppose that there are two quoted programs "),n("code",[e._v("[P]")]),e._v(" and\n    "),n("code",[e._v("[Q]")]),e._v(" on the stack. If the "),n("code",[e._v("dip")]),e._v(" combinator is executed next,\n    it will cause the topmost quotation "),n("code",[e._v("[Q]")]),e._v(" to be executed while saving\n    and later restoring "),n("code",[e._v("[P]")]),e._v(" below. Suppose that the "),n("code",[e._v("i")]),e._v(" combinator\n    is executed next, this will cause the restored "),n("code",[e._v("[P]")]),e._v(" to be executed.\n    So the net effect of the two combinators is to execute first "),n("code",[e._v("P")]),e._v(" and\n    then\n    "),n("code",[e._v("Q")]),e._v(". That same effect could have been achieved by first swapping "),n("code",[e._v("[P]")]),e._v("  and "),n("code",[e._v("[Q]")]),e._v(" around, so that\n    "),n("code",[e._v("[P]")]),e._v(" is on top, and then executing the "),n("code",[e._v("b")]),e._v(" combinator. This\n    is expressed in the left law below. The right law says the same thing, and it shows\n    another way in which the\n    "),n("code",[e._v("b")]),e._v(" combinator could have been defined.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    The combination of the "),t("code",[this._v("dip")]),this._v(" combinator immediately followed by the\n    "),t("code",[this._v("i")]),this._v(" combinator is sometimes useful for arranging the top few elements\n    on the stack in a form that is suitable for executing a quoted program "),t("code",[this._v("[P]")]),this._v("  that is at the top of the stack.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    This is how it is done: first another quoted program\n    "),n("code",[e._v("[Q]")]),e._v(" is pushed, and executed using the "),n("code",[e._v("dip")]),e._v(" combinator.\n    This will save and restore the "),n("code",[e._v("[P]")]),e._v(", but arrange the stack in accordance\n    with "),n("code",[e._v("[Q]")]),e._v(". Then the restored "),n("code",[e._v("[P]")]),e._v(" is executed by the "),n("code",[e._v("i")]),e._v("  combinator. Depending on the "),n("code",[e._v("[Q]")]),e._v(" that is chosen, the three part combination\n    of "),n("code",[e._v("[Q]")]),e._v(", the "),n("code",[e._v("dip")]),e._v(" combinator and the "),n("code",[e._v("i")]),e._v(" combinator\n    will prepare the stack for the execution of "),n("code",[e._v("[P]")]),e._v(".\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    Since such a combination still requires the "),n("code",[e._v("[P]")]),e._v(" on the stack, any\n    such combination has the effect of a combinator. The following illustrate some\n    simple choices of "),n("code",[e._v("[Q]")]),e._v(" that are sometimes useful. The names of these\n    combinators have been chosen because of their similarity to the "),n("em",[e._v("K combinator")]),e._v(",\n    "),n("em",[e._v("W\n    combinator")]),e._v(" and the "),n("em",[e._v("C combinator")]),e._v(" in "),n("em",[e._v("combinatory\n    logic")]),e._v(".\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    Again suppose that there is a quoted program "),n("code",[e._v("[P]")]),e._v(" on top of the stack.\n    It could be executed by some combinator "),n("code",[e._v("C")]),e._v(", or one could do this: push\n    the quotation "),n("code",[e._v("[i]")]),e._v(",\n    "),n("code",[e._v("cons")]),e._v(" the earlier "),n("code",[e._v("[P]")]),e._v(" into that and now execute "),n("code",[e._v("C")]),e._v(".\n    The "),n("code",[e._v("cons")]),e._v(" operation produced\n    "),n("code",[e._v("[[P] i]")]),e._v(" and when this is executed by "),n("code",[e._v("C")]),e._v(", the inner "),n("code",[e._v("[P]")]),e._v("  is pushed partly undoing the "),n("code",[e._v("cons")]),e._v(". Then the "),n("code",[e._v("i")]),e._v(" combinator\n    actually executes this. The net effect is that of just executing "),n("code",[e._v("C")]),e._v(".\n    Hence for all combinators "),n("code",[e._v("C")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    So far we have only encountered one combinator which takes two quoted parameters\n    - the "),t("code",[this._v("b")]),this._v(" combinator. But Joy has a large number of combinators which\n    take two, three or even four quoted parameters. The following concerns combinators\n    which expect at least two quoted programs as parameters. For such combinators the\n    first three laws holds unchanged, but these variations also hold:\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    Finally, the second law generalises to all parameters of a combinator: any one parameter\n    "),n("code",[e._v("[P]")]),e._v(" can be replaced by "),n("code",[e._v("[[P]\n    i]")]),e._v(". The replacement can of course be constructed by\n    "),n("code",[e._v("cons")]),e._v("ing "),n("code",[e._v("[P]")]),e._v(" into "),n("code",[e._v("[i]")]),e._v(". That of course may\n    be done for all quotation parameters. If there is just the one parameter "),n("code",[e._v("[P]")]),e._v(",\n    then "),n("code",[e._v("cons")]),e._v("ing it into\n    "),n("code",[e._v("[i]")]),e._v(" to produce "),n("code",[e._v("[[P] i]")]),e._v(" is easy enough, as in the second\n    law.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    If there are two parameters "),n("code",[e._v("[P]")]),e._v(" and "),n("code",[e._v("[Q]")]),e._v(" it already becomes\n    tedious to change them to "),n("code",[e._v("[[P] i]")]),e._v(" and\n    "),n("code",[e._v("[[Q] i]")]),e._v(". If there are three or more quotation parameters, then the\n    program to produce the three changes could be rather obscure.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    Joy has a combinator which can use a function to "),n("kbd",[e._v("map")]),e._v(" the elements of\n    a list to a list of the same length containing the results of applying the function.\n    Several special forms take as a parameter not an arbitrary list but a specified\n    number of one, two, three and so on elements from the stack. These are the "),n("kbd",[e._v("app1")]),e._v("  combinator, the "),n("kbd",[e._v("app2")]),e._v(" combinator, the "),n("kbd",[e._v("app3")]),e._v(" combinator and\n    so on. These are just the right combinators to produce the changes required for\n    the parameters of a combinator. The following laws hold for combinators "),n("code",[e._v("C1")]),e._v(",\n    "),n("code",[e._v("C2")]),e._v(" and "),n("code",[e._v("C3")]),e._v(" requiring one, two or three quotation parameters:\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ol",[t("li",[this._v(" it requires recursion, or\n    ")]),t("li",[this._v(" it is needed in several seemingly unrelated places in a program, or\n    ")]),t("li",[this._v(" it makes the program clearer.\n    ")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    Consider the following recursive definition and use of the\n    "),t("em",[this._v("factorial")]),this._v(" function in a (fantasy) functional language:\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    The humble "),n("code",[e._v("i")]),e._v(" and "),n("code",[e._v("dip")]),e._v(" combinators were certainly not designed\n    for recursion, so it will come as a surprise that they can be used to emulate recursion\n    without naming the function or its formal parameter. To make the recursion possible,\n    every call of the anonymous function must be able to access itself again, and this\n    is done by giving it its own body as a quoted parameter on the top of the stack.\n    This is achieved by always duplicating the quoted body first and then using the\n    "),n("code",[e._v("i")]),e._v(" combinator to execute the duplicate. The "),n("code",[e._v("dip")]),e._v(" combinator\n    can be used to access the stack below the quoted body. The only other combinator\n    needed is the\n    "),n("code",[e._v("ifte")]),e._v(" combinator which achieves the same kind of two-way branching\n    as the "),n("code",[e._v("if-then-else")]),e._v(" in the conventional definition above.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    The line numbers are only included for reference. Execution begins in line 1 by pushing\n    the actual parameter "),t("code",[this._v("5")]),this._v(" onto the stack. Then the long quotation extending\n    from line 2 to line 7 is pushed onto the stack. This quotation is the body of the\n    function, it corresponds to the right hand side of the conventional definition.\n    Execution continues in line 8 where the long quotation is duplicated and the top\n    copy is executed by the "),t("code",[this._v("i")]),this._v(" combinator. This execution has the effect\n    of pushing the two short quotations in lines 2 and 3 and also the longer quotation\n    in lines 4 to 6. So at this point the stack contains the parameter "),t("code",[this._v("5")]),this._v("  and above that four quotations.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    But now the "),t("code",[this._v("ifte")]),this._v(" combinator in line 7 executes. It pops the last three\n    quotations and saves them elsewhere. Then it executes the if-part, the saved quotation\n    from line 2. That will pop what is now the top of the stack, the body of the function\n    from lines 2 to 7. This exposes the number which is the parameter, and it is compared\n    with "),t("code",[this._v("0")]),this._v(".\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    The comparison will yield a truth value which the "),t("code",[this._v("ifte")]),this._v(" combinator\n    will use to determine whether to execute the saved then-part from line 3 or the\n    saved else-part from lines 4 to 6. In either case the stack is first restored to\n    what it was before the if-part was executed: the quoted body of the function is\n    again on top of the stack and below it is the actual parameter for this particular\n    call. If the most recent comparison by the if-part was true, then the saved then-part\n    from line 3 is executed.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    This results in the body and the actual parameter being popped off the stack and\n    replaced by "),t("code",[this._v("1")]),this._v(", the factorial of "),t("code",[this._v("0")]),this._v(". On the other hand,\n    if the most recent comparison was false, then the saved else-part from lines 4\n    to 6 is executed. For the later multiplication the parameter has to be duplicated\n    and the top duplicate has to be decremented. Since the body of the function is\n    in the way, the duplicating and decrementing is done via the\n    "),t("code",[this._v("dip")]),this._v(" combinator in line 4.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    At this point the top three elements on the stack are the original parameter for\n    this call, then the decremented duplicate, and right on top of that the quoted\n    body of the function. It is now necessary to compute the factorial of the decremented\n    duplicate, and this call may need access to the body again. So the body cannot\n    be simply executed by the "),t("code",[this._v("i")]),this._v(" combinator, but first the body is duplicated\n    in line 5 and then the duplicate is executed by the "),t("code",[this._v("i")]),this._v(" combinator.\n    Execution of that duplicate body will eventually terminate, and then the top two\n    elements will be the original parameter and the factorial of what was its decremented\n    duplicate. The two numbers are now multiplied in line 6, yielding the required\n    factorial of the parameter for this call. This completes the execution of the else-part\n    from lines 4 to 6. Irrespective of whether the then-part or the else-part was executed,\n    the execution of the\n    "),t("code",[this._v("ifte")]),this._v(" combinator is now complete.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    This completes the execution of the body of the function in lines 2 to 7. It also\n    completes the execution of whichever occurrence of the\n    "),n("code",[e._v("i")]),e._v(" combinator in lines 5 or 8 triggered this execution of the body.\n    Ultimately the execution of the "),n("code",[e._v("i")]),e._v(" combinator in line 8 will have completed,\n    and at this point the parameter\n    "),n("code",[e._v("5")]),e._v(" from line 1 will have been replaced by its factorial\n    "),n("code",[e._v("120")]),e._v(" as required.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    Two short comments are in order: Firstly, the "),n("em",[e._v(" description")]),e._v(" of the program\n    was given in an imperative or procedural mode which is psychologically helpful.\n    But this does not change the fact that all Joy programs and all their parts denote\n    functions. Secondly, the program can be written using only the "),n("code",[e._v("dip")]),e._v("  combinator and the "),n("code",[e._v("ifte")]),e._v(" combinator by substituting "),n("code",[e._v("dup dip\n    pop")]),e._v(" for the two calls of the "),n("code",[e._v("i")]),e._v(" combinator in lines 5 and 8.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    Of course this program is a "),t("em",[this._v(" tour de force")]),this._v(", it is ugly and inefficient.\n    With more suitable combinators much crisper and more efficient programs can be\n    written. In particular, the repeated pushing and saving of the quoted if-part,\n    then-part and else-part is not necessary. Also, the repeated duplication of the\n    quoted body is not necessary, and consequently the three parts do not have to work\n    around the quoted body when it is in the way on the top. In fact, the essence of\n    the if-part and most of the else-part are built into the\n    "),t("kbd",[this._v("primrec")]),this._v(" combinator for primitive recursion. The entire program then\n    is\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    The mathematical discipline of "),t("em",[this._v("category theory")]),this._v(" deals with functions of\n    one arguments. All Joy functions are of that kind, too. In fact all monoids are\n    special cases of categories, so Joy's syntactic monoid of concatenation and Joy's\n    semantic monoid of function composition are categories. So some fundamental connections\n    should be expected. In particular, Joy is related to Cartesian closed categories,\n    and to the \"Combinatory Abstract Machine\" "),t("em",[this._v("CAM")]),this._v(", see for example "),t("a",{attrs:{href:"refs.html#{Poigne92}"}},[this._v("{Poigne92}")]),this._v(".\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    The paper\n    "),t("a",{attrs:{href:"/overview-of-joy"}},[this._v("\n    j00ovr ")]),this._v(" contains an overview of Joy and references to other papers dealing\n    with specific aspects of Joy.\n  ")])}]};t.a=i},LsdE:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=n("GTVu"),i=!1;var a=function(e){i||n("NIkK")},s=n("VU/8")(null,o.a,!1,a,"data-v-529cd678",null);s.options.__file="pages/papers-on-joy/mathematical-foundations-of-joy.vue",t.default=s.exports},NIkK:function(e,t,n){var o=n("UPpA");"string"==typeof o&&(o=[[e.i,o,""]]),o.locals&&(e.exports=o.locals);n("rjj0")("8ac3d506",o,!1,{sourceMap:!1})},UPpA:function(e,t,n){(e.exports=n("FZ+f")(!1)).push([e.i,"p[data-v-529cd678]{margin-top:16px;margin-bottom:16px}hr[data-v-529cd678]{margin-bottom:16px}pre[data-v-529cd678]{margin-bottom:auto}code[data-v-529cd678],kbd[data-v-529cd678],pre[data-v-529cd678]{font-family:Roboto Mono,monospace}",""])}});